
        <html>
          <head>
            <style>:root {
            /* Color Palette */
            --bg-color: #f7f9fc;
            --card-bg: #ffffff;
            --primary-color: #0077cc;
            --primary-dark: #005fa3;
            --secondary-color: #e2e8f0;
            --text-color: #334155;
            --text-light: #64748b;
            --accent-volt: #2563eb; /* Blue */
            --accent-curr: #dc2626; /* Red */
            --accent-reset: #64748b; /* Grey for Reset */
            --accent-reset-dark: #475569;
            --shadow-color: rgba(100, 116, 139, 0.12);

            /* Typography */
            --font-family: 'Poppins', sans-serif;

            /* Layout */
            --spacing-unit: 1rem; /* 16px */
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }

        body {
            font-family: var(--font-family);
            background-color: var(--bg-color);
            color: var(--text-color);
            line-height: 1.6;
            padding: calc(var(--spacing-unit) * 1.5);
        }

        h1 {
            text-align: center;
            color: var(--primary-dark);
            margin-bottom: calc(var(--spacing-unit) * 2);
            font-weight: 600;
        }

        .simulation-wrapper {
            display: flex;
            flex-wrap: wrap;
            gap: calc(var(--spacing-unit) * 1.5);
            max-width: 1400px;
            margin: 0 auto;
        }

        .sidebar {
            flex: 1; min-width: 300px; max-width: 350px;
            display: flex; flex-direction: column;
            gap: calc(var(--spacing-unit) * 1.5);
        }

        .main-content {
            flex: 3; min-width: 500px;
            display: flex; flex-wrap: wrap;
            gap: calc(var(--spacing-unit) * 1.5);
        }

        .card {
            background-color: var(--card-bg);
            border-radius: 8px;
            padding: calc(var(--spacing-unit) * 1.25);
            box-shadow: 0 4px 12px var(--shadow-color);
            width: 100%;
        }

        .card h3 {
            font-size: 1.1rem; font-weight: 500; color: var(--primary-dark);
            margin-bottom: var(--spacing-unit);
            border-bottom: 1px solid var(--secondary-color);
            padding-bottom: calc(var(--spacing-unit) * 0.5);
        }

        /* Controls Styling */
        .control-group { margin-bottom: var(--spacing-unit); }
        .control-group label {
            display: block; font-size: 0.85rem; font-weight: 500;
            color: var(--text-light); margin-bottom: calc(var(--spacing-unit) * 0.25);
        }
         .control-group label span { /* Value display */
            float: right; font-weight: 600; color: var(--primary-color);
            background-color: #eef6ff; padding: 0 6px; border-radius: 4px; font-size: 0.8rem;
         }

        input[type="range"] { /* Custom Slider Styles */
            appearance: none; -webkit-appearance: none;
            width: 100%; height: 8px; background: var(--secondary-color);
            border-radius: 5px; cursor: pointer; margin-top: calc(var(--spacing-unit) * 0.5);
        }
        input[type="range"]::-webkit-slider-thumb { /* Slider Thumb (WebKit) */
            appearance: none; -webkit-appearance: none;
            width: 18px; height: 18px; background: var(--primary-color);
            border-radius: 50%; cursor: pointer; border: 2px solid var(--card-bg);
            box-shadow: 0 1px 3px rgba(0,0,0,0.2); margin-top: -5px;
        }
        input[type="range"]::-moz-range-thumb { /* Slider Thumb (Firefox) */
            width: 16px; height: 16px; background: var(--primary-color);
            border-radius: 50%; cursor: pointer; border: none;
             box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        }
         input[type="range"]:hover::-webkit-slider-thumb { background: var(--primary-dark); }
         input[type="range"]:hover::-moz-range-thumb { background: var(--primary-dark); }

        .button-group {
            margin-top: calc(var(--spacing-unit) * 1.25); display: flex;
            gap: calc(var(--spacing-unit) * 0.75); flex-wrap: wrap;
        }
        .button-group button {
            flex-grow: 1; padding: 10px 15px; font-family: var(--font-family);
            font-size: 0.9rem; font-weight: 500; cursor: pointer; border: none;
            border-radius: 6px; color: white;
            transition: background-color 0.2s ease, transform 0.1s ease; text-align: center;
        }
        /* Specific Button Colors */
        #chargeButton, #dischargeButton { background-color: var(--primary-color); }
        #resetButton { background-color: var(--accent-reset); }

        .button-group button:hover:not(:disabled) { transform: translateY(-1px); }
        #chargeButton:hover:not(:disabled), #dischargeButton:hover:not(:disabled) { background-color: var(--primary-dark); }
        #resetButton:hover:not(:disabled) { background-color: var(--accent-reset-dark); }

        .button-group button:disabled {
            background-color: #b0bec5; cursor: not-allowed; transform: none;
        }

        /* Info Display Styling */
        .info-group p {
            font-size: 0.9rem; margin-bottom: calc(var(--spacing-unit) * 0.5);
            display: flex; justify-content: space-between; flex-wrap: wrap; /* Wrap if needed */
        }
        .info-group p span { /* The value part */
            font-weight: 600; color: var(--primary-dark); background-color: #eef6ff;
            padding: 1px 5px; border-radius: 4px; min-width: 65px; text-align: right;
            margin-left: var(--spacing-unit); /* Space between label and value */
        }
        .info-group #statusValue { font-style: italic; color: var(--text-color); background-color: transparent; }

        /* Formulas Styling */
        .formulas {
            font-size: 0.75rem; background-color: #f8fafc; border: 1px dashed var(--secondary-color);
            padding: calc(var(--spacing-unit) * 0.75); border-radius: 5px;
            margin-top: var(--spacing-unit); width: 100%; box-sizing: border-box;
        }
        .formulas p { margin: 3px 0; font-size: inherit;}
        .formulas b { color: var(--primary-dark); font-weight: 600; }
        .formulas sup, .formulas sub { line-height: 0; } /* Improve formula line spacing */

        /* Visuals Area Styling */
        .visuals-container {
             width: 100%; display: flex; flex-direction: column;
             align-items: center; gap: var(--spacing-unit);
        }

        /* ** Refined Circuit Canvas Wrapper ** */
        .circuit-wrapper {
            position: relative; /* Parent for absolute positioning */
            width: 100%; /* Occupy available space */
            max-width: 400px; /* Match canvas explicit width */
            height: 300px; /* Match canvas explicit height */
            margin: 0 auto; /* Center if space allows */
        }

        #circuitCanvas {
            border: 1px solid var(--secondary-color);
            background-color: var(--card-bg);
            display: block;
            max-width: 100%;
            border-radius: 4px;
            /* Positioned statically within the relative wrapper */
        }

        /* ** Refined Dot Container Styling ** */
        #circuitDiagramContainer {
             position: absolute; /* Position relative to circuit-wrapper */
             top: 0; left: 0;
             width: 100%; /* Match wrapper/canvas */
             height: 100%;
             pointer-events: none; /* Clicks pass through */
             overflow: hidden; /* Hide dots that might stray due to rounding */
        }

         .current-dot {
            position: absolute; /* Positioned within container */
            width: 6px; height: 6px;
            background-color: var(--accent-curr); /* Uses CSS variable */
            opacity: 0; /* Start hidden */
            border-radius: 50%;
            transition: opacity 0.1s linear;
            box-shadow: 0 0 4px var(--accent-curr);
        }

        /* Responsive Adjustments */
        @media (max-width: 900px) {
             .main-content { flex-direction: column; min-width: 0; align-items: center; }
             .main-content > .card { width: 100%; max-width: 600px; }
             #graphCanvas { max-width: 100%; }
        }
        @media (max-width: 700px) {
            .simulation-wrapper { flex-direction: column; }
            .sidebar { max-width: 100%; min-width: 0; }
        }
</style>
          </head>
          <body>
             <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600&display=swap" rel="stylesheet">

<h1>RC Circuit Simulation</h1>

<div class="simulation-wrapper">

    <aside class="sidebar">
        <div class="card">
            <h3>Controls & Parameters</h3>
             <div class="control-group">
                <label for="voltageSlider">Voltage Source (Vs): <span id="voltageValue">10</span> V</label>
                <input type="range" id="voltageSlider" min="1" max="20" value="10" step="1">
            </div>
            <div class="control-group">
                <label for="resistanceSlider">Resistance (R): <span id="resistanceValue">1000</span> Ω</label>
                <input type="range" id="resistanceSlider" min="100" max="10000" value="1000" step="100">
            </div>
            <div class="control-group">
                <label for="capacitanceSlider">Capacitance (C): <span id="capacitanceValue">100</span> µF</label>
                <input type="range" id="capacitanceSlider" min="10" max="1000" value="100" step="10">
            </div>
            <div class="button-group">
                <button id="chargeButton">Start Charging</button>
                <button id="dischargeButton" disabled>Start Discharging</button>
                <button id="resetButton">Reset</button>
            </div>
        </div>

        <div class="card">
            <h3>Simulation Status</h3>
            <div class="info-group">
                <p>State: <span id="statusValue">Idle</span></p>
                <p>Time Constant (τ): <span id="tauValue">0.10</span> s</p>
                <p>Elapsed Time (t): <span id="timeValue">0.00</span> s</p>
                <p>Capacitor Voltage (Vc): <span id="vcValue">0.00</span> V</p>
                <p>Circuit Current (I): <span id="currentValue">0.00</span> mA</p>
            </div>
             <div class="formulas">
                 <p><b>Time Constant:</b> τ = R * C</p>
                 <p><b>Charging:</b> Vc(t) = Vs * (1 - e<sup>-t/τ</sup>), I(t) = (Vs/R) * e<sup>-t/τ</sup></p>
                 <p><b>Discharging:</b> Vc(t) = Vc<sub>0</sub> * e<sup>-t/τ</sup>, I(t) = -(Vc<sub>0</sub>/R) * e<sup>-t/τ</sup></p>
            </div>
        </div>
    </aside>

    <main class="main-content">
        <div class="card">
            <h3>Circuit Diagram</h3>
             <div class="circuit-wrapper">
                <canvas id="circuitCanvas" width="400" height="300"></canvas>
                <div id="circuitDiagramContainer"></div> </div>
        </div>

        <div class="card">
            <h3>Graphs (Voltage & Current vs Time)</h3>
            <div class="visuals-container">
                <canvas id="graphCanvas" width="600" height="400"></canvas>
            </div>
        </div>
    </main>

</div>

            <script>const voltageSlider = document.getElementById('voltageSlider');
    const resistanceSlider = document.getElementById('resistanceSlider');
    const capacitanceSlider = document.getElementById('capacitanceSlider');
    const voltageValueSpan = document.getElementById('voltageValue');
    const resistanceValueSpan = document.getElementById('resistanceValue');
    const capacitanceValueSpan = document.getElementById('capacitanceValue');
    const chargeButton = document.getElementById('chargeButton');
    const dischargeButton = document.getElementById('dischargeButton');
    const resetButton = document.getElementById('resetButton');
    const statusValueSpan = document.getElementById('statusValue');
    const tauValueSpan = document.getElementById('tauValue');
    const timeValueSpan = document.getElementById('timeValue');
    const vcValueSpan = document.getElementById('vcValue');
    const currentValueSpan = document.getElementById('currentValue');

    const circuitCanvas = document.getElementById('circuitCanvas');
    const circuitCtx = circuitCanvas.getContext('2d');
    const graphCanvas = document.getElementById('graphCanvas');
    const graphCtx = graphCanvas.getContext('2d');
    const circuitContainer = document.getElementById('circuitDiagramContainer'); // Dots container


    // --- Simulation Parameters & State ---
    let Vs = parseFloat(voltageSlider.value);
    let R = parseFloat(resistanceSlider.value);
    let C = parseFloat(capacitanceSlider.value) * 1e-6;
    let tau = R * C; if (tau <= 1e-9) tau = 1e-9; // Initial safe tau
    let simulationState = 'idle'; // 'idle', 'charging', 'discharging'
    let simulationTime = 0; // s
    let Vc = 0; // V
    let I = 0; // A
    let Vc_initial = 0; // V
    let animationFrameId = null;
    let lastTimestamp = 0; // ms
    let graphData = { t: [], vc: [], i: [] };
    const MAX_GRAPH_TIME_FACTOR = 5.5;
    let maxGraphTime = MAX_GRAPH_TIME_FACTOR * tau;
    const NUM_CURRENT_DOTS = 12;
    const currentDots = [];
    let circuitPath = { charge: null, discharge: null };
    let circuitLayoutCoords = {}; // To store calculated layout points

    // --- CONSOLIDATED Color definitions for JS Canvas drawing ---
    const themeColors = {
        // General
        primary: '#0077cc',     // Main accent color
        text: '#334155',        // Default text
        textLight: '#64748b',   // Lighter text for labels
        grid: '#e2e8f0',        // Graph grid lines
        wire: '#94a3b8',        // Circuit wires (was #cbd5e1, made slightly darker)

        // Accents
        volt: '#2563eb',        // Voltage graph line, Vs symbol details (if any)
        curr: '#dc2626',        // Current graph line, current dots (matches CSS)
        chargeFill: 'rgba(37, 99, 235, 0.4)', // Capacitor fill (slightly less opaque)

        // Components
        voltageSourceBody: '#334155',
        voltageSourceTerminal: '#334155', // Color for +/-
        resistorBody: '#334155',
        resistorTerminal: '#94a3b8', // Dots on resistor ends
        capacitorPlate: '#334155',
        capacitorTerminal: '#94a3b8', // Dots on capacitor ends

        // Switch Specific
        switchPivot: '#64748b',       // Pivot point color
        switchContact: '#64748b',    // Contact point color
        switchArmOpen: '#cbd5e1',     // Arm color when open
        switchArmClosed: '#0077cc',    // Arm color when closed (matches primary)
    };


    // --- Component Drawing Helpers (Using Consolidated themeColors) ---

    function drawVoltageSourceSymbol(ctx, x, y, radius) {
        // Outer circle
        ctx.strokeStyle = themeColors.voltageSourceBody;
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, 2 * Math.PI);
        ctx.stroke();
        // Inner +/- signs
        const signSize = radius * 0.35;
        ctx.strokeStyle = themeColors.voltageSourceTerminal; // Use terminal color
        ctx.lineWidth = 2;
        // Plus (+) - Top
        ctx.beginPath();
        ctx.moveTo(x - signSize, y - radius * 0.5); ctx.lineTo(x + signSize, y - radius * 0.5); // Horizontal
        ctx.moveTo(x, y - radius * 0.5 - signSize); ctx.lineTo(x, y - radius * 0.5 + signSize); // Vertical
        ctx.stroke();
        // Minus (-) - Bottom
        ctx.beginPath();
        ctx.moveTo(x - signSize, y + radius * 0.5); ctx.lineTo(x + signSize, y + radius * 0.5); // Horizontal only
        ctx.stroke();

        // Label
        ctx.fillStyle = themeColors.textLight;
        ctx.fillText("Vs", x + radius + 8, y + 4);
        ctx.lineWidth = 1.5; // Reset
    }


    function drawResistorSymbol(ctx, x, y, width, height) {
        const numZigzags = 6;
        const segmentWidth = width / numZigzags;
        const terminalLength = 0; // No extra terminal length needed if wires connect directly

        ctx.strokeStyle = themeColors.resistorBody; // Use specific resistor color
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        // Left starting point
        ctx.moveTo(x - width / 2 - terminalLength, y);
        // Zigzags
        for (let i = 0; i < numZigzags; i++) {
            const currentX = x - width / 2 + i * segmentWidth;
            const nextX = currentX + segmentWidth;
            const yOffset = (i % 2 === 0) ? -height / 2 : height / 2;
            ctx.lineTo(nextX, y + yOffset);
        }
        // Ensure last point is back at y=0 if numZigzags is even
        if (numZigzags % 2 === 0) {
            ctx.lineTo(x + width / 2 + terminalLength, y);
        }
        ctx.stroke();

        // Label
        ctx.fillStyle = themeColors.textLight;
        ctx.fillText("R", x, y - height / 2 - 12); // Adjust label position
    }


    function drawCapacitorSymbol(ctx, x, y, plateLength, gap) {
        // Terminal connections (relative to center x, y)
        const termYOffset = plateLength / 2;
        const termXLeft = x - gap / 2;
        const termXRight = x + gap / 2;

        ctx.strokeStyle = themeColors.capacitorPlate; // Use specific capacitor color
        ctx.lineWidth = 2.5; // Make plates thicker

        // Left plate
        ctx.beginPath();
        ctx.moveTo(termXLeft, y - termYOffset);
        ctx.lineTo(termXLeft, y + termYOffset);
        ctx.stroke();

        // Right plate
        ctx.beginPath();
        ctx.moveTo(termXRight, y - termYOffset);
        ctx.lineTo(termXRight, y + termYOffset);
        ctx.stroke();

        // Label
        ctx.fillStyle = themeColors.textLight;
        ctx.fillText("C", x, y - plateLength / 2 - 12);

        // Charge visualization fill
        const chargeLevel = Math.max(0, Math.min(1, Vc_initial > 0 ? Math.abs(Vc / Vc_initial) : (Vs > 0 ? Math.abs(Vc/Vs) : 0) ));
        if (!isNaN(chargeLevel) && chargeLevel > 0.01) {
            ctx.fillStyle = themeColors.chargeFill;
            const fillHeight = plateLength * chargeLevel;
             // Fill from bottom up
            ctx.fillRect(termXLeft + 1, y + termYOffset - fillHeight, (termXRight - termXLeft) - 2 , fillHeight); // Inset slightly
        }

        ctx.lineWidth = 1.5; // Reset default
    }

    // ** Using the flexible drawSwitchSymbol **
    function drawSwitchSymbol(ctx, x, y, length, angle, label, isOpen, closedAngle = 0) {
        const pivotRadius = 4;
        const contactRadius = 3;

        // Calculate contact point based on the *desired closed angle*
        const contactX = x + length * Math.cos(closedAngle);
        const contactY = y + length * Math.sin(closedAngle);

        // Pivot point
        ctx.fillStyle = themeColors.switchPivot;
        ctx.beginPath(); ctx.arc(x, y, pivotRadius, 0, 2 * Math.PI); ctx.fill();

        // Contact point (drawn at the calculated closed position)
        ctx.fillStyle = themeColors.switchContact;
        ctx.beginPath(); ctx.arc(contactX, contactY, contactRadius, 0, 2 * Math.PI); ctx.fill();

        // Switch arm (drawn at the current 'angle')
        ctx.beginPath(); ctx.moveTo(x, y); // Start at pivot
        const endX = x + length * Math.cos(angle);
        const endY = y + length * Math.sin(angle);
        ctx.lineTo(endX, endY);
        ctx.lineWidth = 3.5;
        ctx.strokeStyle = isOpen ? themeColors.switchArmOpen : themeColors.switchArmClosed;
        ctx.lineCap = 'round';
        ctx.stroke();
        ctx.lineCap = 'butt'; // Reset
        ctx.lineWidth = 1.5; // Reset default

        // Label (improved positioning)
        ctx.fillStyle = themeColors.textLight;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        // Position label near the contact point, offset based on closed angle
        const labelDist = length + 15; // Distance from pivot
        const labelAngle = closedAngle; // Place label relative to closed position
        const labelX = x + labelDist * Math.cos(labelAngle);
        const labelY = y + labelDist * Math.sin(labelAngle);
        ctx.fillText(label, labelX, labelY);
        ctx.textAlign = 'left'; // Reset alignment
        ctx.textBaseline = 'alphabetic'; // Reset baseline

        // Return points
        return {
            pivot: { x: x, y: y },
            contact: { x: contactX, y: contactY }, // Where arm lands at closedAngle
            armEnd: { x: endX, y: endY }           // Current end of the arm
        };
    }


    // --- Main Circuit Drawing Function ---
    function drawCircuit(isInitialLayoutCalc = false) {
        const ctx = circuitCtx; const w = 400; const h = 300;
        if (!isInitialLayoutCalc) { // Only clear if not calculating layout
             ctx.clearRect(0, 0, w, h);
        }
        const defaultWireColor = themeColors.wire; ctx.lineWidth = 1.5;
        ctx.font = "11px " + (typeof getComputedStyle !== 'undefined' ? getComputedStyle(document.body).fontFamily : 'sans-serif');
        ctx.fillStyle = themeColors.text; ctx.lineCap = 'round';

        // Component Properties & Layout Coords
        const vsRadius = 18; const rWidth = 50; const rHeight = 20; const cPlateLen = 30; const cGap = 10; const swLength = 35;
        const margin = 45; const topY = margin + 10; const bottomY = h - margin; const leftX = margin + 20; const rightX = w - margin - 20; const midX = w / 2;
        const vsPos = { x: leftX, y: (topY + bottomY) / 2 };
        const sw1Pos = { x: midX - 60, y: topY }; // SW1 pivot
        const rPos = { x: midX + 40, y: topY };    // Resistor center
        const cPos = { x: rightX, y: (topY + bottomY) / 2 }; // Capacitor center
        const sw2Pos = { x: midX, y: bottomY }; // SW2 pivot bottom-center

        // --- Draw Components ---
        drawVoltageSourceSymbol(ctx, vsPos.x, vsPos.y, vsRadius);
        // Terminals calculated relative to component center for wiring
        const rTerminals = { left: {x: rPos.x - rWidth/2, y: rPos.y}, right: {x: rPos.x + rWidth/2, y: rPos.y}};
        drawResistorSymbol(ctx, rPos.x, rPos.y, rWidth, rHeight);
        const cTerminals = { left: {x: cPos.x - cGap/2, y: cPos.y}, right: {x: cPos.x + cGap/2, y: cPos.y}};
        drawCapacitorSymbol(ctx, cPos.x, cPos.y, cPlateLen, cGap);

        // --- Draw Switches ---
        // SW1: Closes horizontally (closedAngle=0 is default)
        const chargeSwitchOpen = simulationState !== 'charging';
        const chargeSwitchAngle = chargeSwitchOpen ? -Math.PI / 2.3 : 0; // Open up, close horizontal (0)
        const sw1Points = drawSwitchSymbol(ctx, sw1Pos.x, sw1Pos.y, swLength, chargeSwitchAngle, "SW1", chargeSwitchOpen); // closedAngle defaults to 0

        // SW2: Closes downwards
        const dischargeSwitchOpen = simulationState !== 'charging';
        const sw2ClosedAngle = Math.PI / 2;       // Angle when closed (pointing down)
        const sw2OpenAngle = Math.PI * 1.1;      // Angle when open (more towards left)
        const dischargeSwitchAngle = dischargeSwitchOpen ? sw2OpenAngle : sw2ClosedAngle;
        const sw2Points = drawSwitchSymbol(ctx, sw2Pos.x, sw2Pos.y, swLength, dischargeSwitchAngle, "SW2", dischargeSwitchOpen, sw2ClosedAngle);

        // --- Draw Wires ---
        ctx.strokeStyle = defaultWireColor;
        ctx.beginPath();

        // TOP PATH (Vs+ -> SW1 -> R -> C+)
        ctx.moveTo(vsPos.x, vsPos.y - vsRadius);                  // Vs Top
        ctx.lineTo(vsPos.x, sw1Points.pivot.y);                   // Up to SW1 Y level
        ctx.lineTo(sw1Points.pivot.x, sw1Points.pivot.y);         // To SW1 Pivot
        // Wire from SW1 contact to Resistor Left (drawn regardless of switch state)
        ctx.moveTo(sw1Points.contact.x, sw1Points.contact.y);
        ctx.lineTo(rTerminals.left.x, rTerminals.left.y);         // To R Left
        // Resistor Right to Capacitor Left/Top
        ctx.moveTo(rTerminals.right.x, rTerminals.right.y);
        ctx.lineTo(cTerminals.left.x, topY);                     // Across at top Y
        ctx.lineTo(cTerminals.left.x, cPos.y - cPlateLen/2);     // Down to C Plate Top

        // BOTTOM PATH (Vs- -> SW2 -> C-)
        ctx.moveTo(vsPos.x, vsPos.y + vsRadius);                  // Vs Bottom
        ctx.lineTo(vsPos.x, sw2Points.pivot.y);                   // Down to SW2 Y level
        ctx.lineTo(sw2Points.pivot.x, sw2Points.pivot.y);         // To SW2 Pivot
        // Wire from SW2 contact to Capacitor Right/Bottom (drawn regardless of switch state)
        // **Corrected wiring for downward closing SW2**
        ctx.moveTo(sw2Points.contact.x, sw2Points.contact.y);     // From SW2 Contact point (now below pivot)
        ctx.lineTo(cTerminals.right.x, sw2Points.contact.y);     // Horizontally to C's X position
        ctx.lineTo(cTerminals.right.x, cPos.y + cPlateLen / 2);    // Up to C Plate Bottom

        ctx.stroke(); // Draw all wire paths

        // Optional: Draw filled circles on contacts when closed to emphasize connection
        if (!chargeSwitchOpen) {
            ctx.fillStyle = themeColors.switchArmClosed; ctx.beginPath();
            ctx.arc(sw1Points.contact.x, sw1Points.contact.y, 3.5, 0, 2 * Math.PI); ctx.fill();
        }
        if (!dischargeSwitchOpen) {
            ctx.fillStyle = themeColors.switchArmClosed; ctx.beginPath();
            ctx.arc(sw2Points.contact.x, sw2Points.contact.y, 3.5, 0, 2 * Math.PI); ctx.fill();
        }

        // Store coordinates if called for layout calculation
        if (isInitialLayoutCalc) {
            circuitLayoutCoords = {
                vsPos, vsRadius, sw1Points, rTerminals, cTerminals, cPos, cPlateLen, sw2Points, topY, bottomY
            };
        }

        // Reset style
        ctx.lineCap = 'butt';
    }


     // --- Recalculate Path (Uses dynamic layout coordinates) ---
     function calculateCircuitPath() {
        // Ensure layout coordinates are available
        if (!circuitLayoutCoords.vsPos) {
             console.error("Cannot calculate path: Layout coordinates not available.");
             return;
        }
        const { vsPos, vsRadius, sw1Points, rTerminals, cTerminals, cPos, cPlateLen, sw2Points, topY, bottomY } = circuitLayoutCoords;

        // Charging Path: Vs+ -> SW1 -> R -> C+ -> C- -> Vs- (assuming SW2 is irrelevant for charge path)
         const chargePathRaw = [
             { x: vsPos.x, y: vsPos.y - vsRadius },               // Vs Top
             { x: vsPos.x, y: sw1Points.pivot.y },                // Up to SW1 Y
             { x: sw1Points.pivot.x, y: sw1Points.pivot.y },      // -> SW1 Pivot
             sw1Points.contact,                                   // Across SW1 (pivot to contact directly for animation)
             { x: rTerminals.left.x, y: rTerminals.left.y },      // -> R Left
             rTerminals.right,                                    // Through R
             { x: cTerminals.left.x, y: topY },                   // -> Across top Y level
             { x: cTerminals.left.x, y: cPos.y - cPlateLen / 2 }, // -> Down to C Top Plate

             // Path continues from C Bottom Plate -> Vs Bottom (Common ground)
             { x: cTerminals.right.x, y: cPos.y + cPlateLen / 2 },// C Bottom Plate
             { x: cTerminals.right.x, y: bottomY },               // Down to bottom Y level
             { x: vsPos.x, y: bottomY },                          // Across to Vs X position
             { x: vsPos.x, y: vsPos.y + vsRadius }                // Up to Vs Bottom
         ];

         // Discharge Path: C+ -> R -> SW2 -> C-
         const dischargePathRaw = [
             { x: cTerminals.left.x, y: cPos.y - cPlateLen / 2 }, // C Top Plate
             { x: cTerminals.left.x, y: topY },                   // Up to top Y level
             rTerminals.right,                                    // -> R Right
             rTerminals.left,                                     // Through R (R->L)
             sw1Points.contact,                                   // -> SW1 Contact (part of top wire)
             sw1Points.pivot,                                     // -> SW1 Pivot (part of top wire)
             // Now need path from top wire to SW2 pivot/contact area...
             // Let's simplify: Assume discharge goes R -> SW2 Contact -> C-
             // Re-start path after R:
             rTerminals.left,                                      // R Left
             { x: rTerminals.left.x, y: sw2Points.contact.y },     // Directly down to SW2 contact Y level (approx)
             sw2Points.contact,                                    // -> SW2 Contact Point
             // Across SW2 (contact to pivot directly for animation)
             sw2Points.pivot,
             // Back to C- via bottom wire segment
             { x: cTerminals.right.x, y: sw2Points.contact.y },     // -> Horizontally to C X position (at SW2 contact Y)
             { x: cTerminals.right.x, y: cPos.y + cPlateLen / 2 }  // -> Up to C Bottom Plate
         ];


         function processPath(rawPath) {
             if (!rawPath || rawPath.length < 2) return { points: [], totalLength: 0 };
             let processed = [{ x: rawPath[0].x, y: rawPath[0].y, dist: 0, dx: 0, dy: 0, segLen: 0 }];
             let totalDist = 0;
             for (let i = 1; i < rawPath.length; i++) {
                 const p1 = processed[processed.length-1]; // Use last *processed* point
                 const p2 = rawPath[i];
                 // Skip duplicate consecutive points
                 if (Math.abs(p2.x - p1.x) < 1e-6 && Math.abs(p2.y - p1.y) < 1e-6) continue;

                 const dx = p2.x - p1.x;
                 const dy = p2.y - p1.y;
                 const segDist = Math.sqrt(dx*dx + dy*dy);
                 if (segDist < 1e-6) continue; // Skip zero-length segments

                 const normX = dx / segDist;
                 const normY = dy / segDist;
                 totalDist += segDist;
                 processed.push({ x: p2.x, y: p2.y, dist: totalDist, dx: normX, dy: normY, segLen: segDist });
             }
             // Set direction for the first point based on the second
             if(processed.length > 1) {
                 processed[0].dx = processed[1].dx;
                 processed[0].dy = processed[1].dy;
                 processed[0].segLen = processed[1].segLen;
             } else if (processed.length === 1) { // Handle single point case
                 processed[0].dx = 1; processed[0].dy = 0; processed[0].segLen = 0;
             }

             return { points: processed, totalLength: totalDist };
         }

         circuitPath.charge = processPath(chargePathRaw);
         circuitPath.discharge = processPath(dischargePathRaw);
         // console.log("Charge Path:", circuitPath.charge);
         // console.log("Discharge Path:", circuitPath.discharge);
     }

    // --- Graph Drawing (Mostly unchanged, using consolidated themeColors) ---
    function drawGraph() {
        const ctx = graphCtx; const w = graphCanvas.width; const h = graphCanvas.height; const padding = 50;
        ctx.clearRect(0, 0, w, h); ctx.fillStyle = '#ffffff'; ctx.fillRect(0, 0, w, h); // Ensure background is white
        ctx.strokeStyle = themeColors.grid; ctx.lineWidth = 1;
        ctx.font = "11px " + (typeof getComputedStyle !== 'undefined' ? getComputedStyle(document.body).fontFamily : 'sans-serif');
        ctx.fillStyle = themeColors.textLight;

        // Y Axes Lines & Labels
        ctx.beginPath(); ctx.moveTo(padding, padding); ctx.lineTo(padding, h - padding); ctx.moveTo(w - padding, padding); ctx.lineTo(w - padding, h - padding); ctx.stroke(); // Y Axes lines
        ctx.textAlign = "right"; ctx.fillStyle = themeColors.volt; ctx.fillText("Vc (V)", padding - 10, padding - 8);
        ctx.textAlign = "left"; ctx.fillStyle = themeColors.curr; ctx.fillText("I (mA)", w - padding + 10, padding - 8);

        // X Axis Line & Label
        ctx.beginPath(); ctx.moveTo(padding, h - padding); ctx.lineTo(w - padding, h - padding); ctx.stroke(); // X Axis line
        ctx.textAlign = "center"; ctx.fillStyle = themeColors.textLight; ctx.fillText("Time (s)", w / 2, h - padding + 30);

        // Calculate Scales
        const maxV = Math.max(Math.abs(Vs), Math.abs(Vc_initial), 1); // Ensure maxV is at least 1
        const maxI_charge_initial = R > 0 ? Math.abs(Vs / R * 1000) : 1; // mA
        const maxI_discharge_initial = R > 0 ? Math.abs(Vc_initial / R * 1000) : 0; // mA
        const maxI = Math.max(maxI_charge_initial, maxI_discharge_initial, 1); // Ensure maxI is at least 1 mA
        const graphHeight = h - 2 * padding; const graphWidth = w - 2 * padding;
        const effectiveMaxGraphTime = Math.max(maxGraphTime, 0.1); // Ensure graph time is not zero
        const xScale = graphWidth / effectiveMaxGraphTime;
        const vScale = graphHeight / maxV;
        const iScale = graphHeight / (maxI * 2); // Scale for +/- maxI range
        const iZeroY = h - padding - graphHeight / 2; // Y position for I=0

        // Draw Grid Lines & Labels
        ctx.strokeStyle = themeColors.grid; ctx.lineWidth = 0.8; const numTicks = 5;
        ctx.textAlign = "center"; ctx.fillStyle = themeColors.textLight;
        // Time Grid/Labels
        for (let i = 0; i <= numTicks; i++) {
            const t = (i / numTicks) * effectiveMaxGraphTime; const x = padding + t * xScale;
            ctx.beginPath(); ctx.moveTo(x, padding); ctx.lineTo(x, h - padding); ctx.stroke();
            ctx.fillText(t.toFixed(2), x, h - padding + 15);
            // Mark Tau
            if (Math.abs(t - tau) < (effectiveMaxGraphTime / numTicks / 2) && tau > 0.001) {
                 ctx.fillStyle = themeColors.primary; ctx.fillText("τ", x, h-padding + 28); ctx.fillStyle = themeColors.textLight;
            }
        }
        // Voltage Grid/Labels
        ctx.textAlign = "right"; ctx.fillStyle = themeColors.volt;
        for (let i = 0; i <= numTicks; i++) {
            const v = (i / numTicks) * maxV; const y = h - padding - v * vScale;
            ctx.beginPath(); ctx.moveTo(padding, y); ctx.lineTo(w - padding, y); ctx.stroke();
            ctx.fillText(v.toFixed(1), padding - 10, y + 4);
        }
        // Current Grid/Labels
        ctx.textAlign = "left"; ctx.fillStyle = themeColors.curr;
        for (let i = -numTicks; i <= numTicks; i++) {
            const cur = (i / numTicks) * maxI; const y = iZeroY - cur * iScale;
            ctx.beginPath(); ctx.moveTo(padding, y); ctx.lineTo(w - padding, y);
            if(i === 0) { ctx.strokeStyle = '#cbd5e1'; ctx.stroke(); ctx.strokeStyle = themeColors.grid;} // Make zero line slightly different
            else { ctx.stroke(); }
             ctx.fillText(cur.toFixed(1), w - padding + 10, y + 4);
        }

        // Plot Data
        ctx.lineWidth = 2.5;
        if (graphData.t.length > 1) {
            // Plot Vc
            ctx.strokeStyle = themeColors.volt; ctx.beginPath(); ctx.moveTo(padding + graphData.t[0] * xScale, h - padding - graphData.vc[0] * vScale);
            for (let i = 1; i < graphData.t.length; i++) {
                const x = padding + graphData.t[i] * xScale; const y_v = h - padding - graphData.vc[i] * vScale;
                if (x <= w - padding + 1) { ctx.lineTo(x, y_v); } else {
                    // Interpolate to edge if exceeds graph boundary
                    const pX = padding + graphData.t[i-1] * xScale; const pY = h - padding - graphData.vc[i-1] * vScale;
                    if (Math.abs(x - pX) > 1e-6) { // Avoid division by zero
                        const m = (y_v - pY) / (x - pX);
                        ctx.lineTo(w - padding, pY + m * (w - padding - pX));
                    }
                    break;
                }
            }
             ctx.stroke();

            // Plot I (mA)
            ctx.strokeStyle = themeColors.curr; ctx.beginPath(); ctx.moveTo(padding + graphData.t[0] * xScale, iZeroY - (graphData.i[0] * 1000) * iScale);
            for (let i = 1; i < graphData.t.length; i++) {
                const x = padding + graphData.t[i] * xScale; const y_i = iZeroY - (graphData.i[i] * 1000) * iScale;
                if (x <= w - padding + 1) { ctx.lineTo(x, y_i); } else {
                     // Interpolate to edge
                     const pX = padding + graphData.t[i-1] * xScale; const pY = iZeroY - (graphData.i[i-1] * 1000) * iScale;
                     if (Math.abs(x - pX) > 1e-6) {
                        const m = (y_i - pY) / (x - pX);
                        ctx.lineTo(w - padding, pY + m * (w - padding - pX));
                     }
                    break;
                }
            }
             ctx.stroke();
        }
        ctx.lineWidth = 1; // Reset line width
    }


    // --- Dot Animation (Uses CSS for styling) ---
    function createCurrentDots() {
        circuitContainer.innerHTML = ''; // Clear previous dots
        currentDots.length = 0;
        for (let i = 0; i < NUM_CURRENT_DOTS; i++) {
            const dot = document.createElement('div');
            dot.className = 'current-dot';
            circuitContainer.appendChild(dot);
            currentDots.push({ element: dot, offset: Math.random() }); // Random initial position along path
        }
    }

    function updateCurrentDots(pathData, currentMagnitude, direction = 1) {
         // Hide dots immediately if no current or path
        if (!pathData || !pathData.points || pathData.points.length < 2 || pathData.totalLength <= 0 || Math.abs(currentMagnitude) < 1e-6) {
            currentDots.forEach(dot => dot.element.style.opacity = '0');
            return;
        }

        // Calculate speed based on current magnitude (adjust scaling factor as needed)
        const baseSpeed = pathData.totalLength * 0.15; // Base distance per second
        const speedMultiplier = 1 + Math.log1p(Math.abs(currentMagnitude * 1000)); // Non-linear scaling
        const speed = baseSpeed * speedMultiplier; // Pixels per second
        const dt = Math.min((performance.now() - (lastTimestamp || performance.now())) / 1000, 0.05); // Delta time in seconds, capped

        currentDots.forEach(dot => {
            // Update offset based on speed and direction
            dot.offset += direction * (speed / pathData.totalLength) * dt;
            dot.offset %= 1.0; // Wrap around the path (0 to 1)
            if (dot.offset < 0) dot.offset += 1.0;

            // Find position on path corresponding to the offset
            const targetDist = dot.offset * pathData.totalLength;
            let currentX = pathData.points[0].x;
            let currentY = pathData.points[0].y;

            for (let i = 1; i < pathData.points.length; i++) {
                const p1 = pathData.points[i - 1];
                const p2 = pathData.points[i];
                // Check if target distance is within this segment
                if (targetDist >= p1.dist && targetDist <= p2.dist && p2.segLen > 0) {
                    const segmentOffset = targetDist - p1.dist;
                    // Interpolate position along the segment
                    currentX = p1.x + p2.dx * segmentOffset;
                    currentY = p1.y + p2.dy * segmentOffset;
                    break;
                 }
                 // Handle edge case if targetDist is beyond the last point (due to rounding)
                 if (i === pathData.points.length - 1 && targetDist > p2.dist) {
                     currentX = p2.x;
                     currentY = p2.y;
                 }
            }

            // Update dot element position and opacity
            dot.element.style.left = `${currentX - 3}px`; // Center dot (width/2)
            dot.element.style.top = `${currentY - 3}px`; // Center dot (height/2)
             // Fade in/out based on current magnitude (adjust multiplier for sensitivity)
            dot.element.style.opacity = Math.min(1, Math.abs(currentMagnitude * 1500));
        });
    }


    // --- Core Simulation Logic & Event Handlers ---
    function init() {
        updateParameterDisplays();
        calculateTau();
        createCurrentDots();
        drawCircuit(true); // Perform initial draw *to calculate layout*
        calculateCircuitPath(); // Calculate path using the layout coords
        resetSimulation(); // Reset state, draw final initial view, set buttons
        setupEventListeners();
        console.log("RC Simulation Initialized (Corrected)");
    }

    function setupEventListeners() {
        voltageSlider.addEventListener('input', handleParameterChange);
        resistanceSlider.addEventListener('input', handleParameterChange);
        capacitanceSlider.addEventListener('input', handleParameterChange);
        chargeButton.addEventListener('click', startCharging);
        dischargeButton.addEventListener('click', startDischarging);
        resetButton.addEventListener('click', resetSimulation);
    }

    function handleParameterChange(event) {
        // Stop any running simulation if parameters change
        if (simulationState !== 'idle') {
             resetSimulation(); // This stops animation and resets state
        } else {
            // If already idle, still need to potentially update visuals/paths
             Vc = 0; // Ensure Vc is zero if changing params while idle
             I = 0;
             simulationTime = 0;
             Vc_initial = 0;
             resetSimulationData(); // Clear graph data
        }

        Vs = parseFloat(voltageSlider.value);
        R = parseFloat(resistanceSlider.value);
        C = parseFloat(capacitanceSlider.value) * 1e-6;

        updateParameterDisplays();
        calculateTau();
        drawCircuit(true); // Recalculate layout
        calculateCircuitPath(); // Recalculate path
        drawGraph(); // Update graph axes/grid
        updateInfoDisplay(); // Update numeric displays

        // Set button states for idle
        chargeButton.disabled = false;
        dischargeButton.disabled = true; // Can't discharge from 0V
    }


    function updateParameterDisplays() {
        voltageValueSpan.textContent = Vs.toFixed(0);
        resistanceValueSpan.textContent = R.toFixed(0);
        capacitanceValueSpan.textContent = (C * 1e6).toFixed(0);
    }

    function calculateTau() {
        tau = R * C;
        if (tau <= 1e-9) tau = 1e-9; // Avoid division by zero or infinite loop
        tauValueSpan.textContent = tau.toFixed(2);
        maxGraphTime = MAX_GRAPH_TIME_FACTOR * tau;
    }

    function startCharging() {
        if (simulationState !== 'idle') return; // Prevent starting if already running
        // Can always start charging from any Vc state (even if Vc=Vs already)
        resetSimulationData(); // Clear time and graph data
        simulationState = 'charging';
        Vc_initial = Vc; // Store voltage at the start of this phase
        statusValueSpan.textContent = "Charging";
        chargeButton.disabled = true;
        dischargeButton.disabled = true; // Disable discharge during charge
        lastTimestamp = performance.now();
        if (!animationFrameId) animationFrameId = requestAnimationFrame(animate);
    }

    function startDischarging() {
        // Only allow discharging if idle AND capacitor has some charge
        if (simulationState !== 'idle' || Math.abs(Vc) < 0.01) return;
        resetSimulationData(); // Clear time and graph data
        simulationState = 'discharging';
        Vc_initial = Vc; // Store voltage at the start of this phase
        statusValueSpan.textContent = "Discharging";
        chargeButton.disabled = true; // Disable charge during discharge
        dischargeButton.disabled = true;
        lastTimestamp = performance.now();
        if (!animationFrameId) animationFrameId = requestAnimationFrame(animate);
    }

    function resetSimulation() {
        if (animationFrameId) cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
        simulationState = 'idle';
        statusValueSpan.textContent = "Idle";
        Vc = 0; // Reset voltage to 0
        I = 0;  // Reset current to 0
        simulationTime = 0;
        Vc_initial = 0;
        resetSimulationData(); // Clear graph data

        // Set button states based on Vc=0
        chargeButton.disabled = false; // Can always charge from 0V
        dischargeButton.disabled = true;  // Cannot discharge from 0V

        updateInfoDisplay();
        drawCircuit(); // Redraw circuit in idle state (switches open)
        drawGraph();   // Redraw graph (empty)
        updateCurrentDots(null, 0); // Ensure dots are hidden
    }

     function resetSimulationData() {
         simulationTime = 0;
         graphData = { t: [], vc: [], i: [] };
     }

    function simulationStep(deltaTime) {
        if (tau <= 0 || simulationState === 'idle') return false; // Return false = simulation didn't stop

        const dt = Math.min(deltaTime, 0.1); // Cap delta time for stability
        if (dt <= 0) return false;

        simulationTime += dt;
        let stopSimulation = false;
        let finalState = "Idle";
        let stateChanged = true;

        if (simulationState === 'charging') {
            Vc = Vc_initial + (Vs - Vc_initial) * (1 - Math.exp(-simulationTime / tau));
            I = R > 0 ? (Vs - Vc) / R : 0;
             // Stop condition: close enough to target voltage or time exceeded
            if (simulationTime >= maxGraphTime || Math.abs(Vs - Vc) < 0.005 * Math.max(Math.abs(Vs), 1)) {
                Vc = Vs; I = 0; stopSimulation = true; finalState = "Charged";
            }
        } else if (simulationState === 'discharging') {
            Vc = Vc_initial * Math.exp(-simulationTime / tau);
            I = R > 0 ? -Vc / R : 0; // Current is negative during discharge
             // Stop condition: close enough to zero or time exceeded
             if (simulationTime >= maxGraphTime || Math.abs(Vc) < 0.005 * Math.max(Math.abs(Vs), Math.abs(Vc_initial), 1)) {
                Vc = 0; I = 0; stopSimulation = true; finalState = "Discharged";
            }
        } else {
            stateChanged = false; // No change if idle
        }

        if(stateChanged) {
            graphData.t.push(simulationTime);
            graphData.vc.push(Vc);
            graphData.i.push(I);
            updateInfoDisplay();
        }

        if(stopSimulation) {
            simulationState = 'idle';
            statusValueSpan.textContent = `${finalState} (Idle)`;
            // Update button states based on the final voltage
            chargeButton.disabled = false; // Can always try to charge again
            dischargeButton.disabled = (Math.abs(Vc) < 0.01); // Only enable if some charge remains

            // Ensure V/I are exactly the final values
            if (finalState === "Charged") { Vc = Vs; I = 0; }
            if (finalState === "Discharged") { Vc = 0; I = 0; }
            updateInfoDisplay(); // Show final values
            return true; // Indicate simulation stopped this step
        }
        return false; // Indicate simulation continuing
    }

    function updateInfoDisplay() {
        timeValueSpan.textContent = simulationTime.toFixed(2);
        vcValueSpan.textContent = Vc.toFixed(2);
        currentValueSpan.textContent = (I * 1000).toFixed(2); // Display current in mA
    }

    function animate(timestamp) {
        if (!lastTimestamp) lastTimestamp = timestamp;
        const deltaTime = (timestamp - lastTimestamp) / 1000;
        lastTimestamp = timestamp;

        // Update simulation state and check if it stopped
        const stopped = simulationStep(deltaTime);

        // Always redraw circuit and graph based on current state
        drawCircuit();
        drawGraph();

        // Update dot animation based on current state
        if (simulationState === 'charging') {
            updateCurrentDots(circuitPath.charge, I, 1); // Positive current direction
        } else if (simulationState === 'discharging') {
             // Use absolute value for dot speed/opacity, but path direction might need reversing depending on definition
            updateCurrentDots(circuitPath.discharge, Math.abs(I), 1); // Assuming discharge path is defined C+ -> C-
        } else {
            updateCurrentDots(null, 0); // Hide dots if idle
        }

        // Request next frame ONLY if simulation didn't stop and is not idle
        if (!stopped && simulationState !== 'idle') {
           animationFrameId = requestAnimationFrame(animate);
        } else {
            animationFrameId = null; // Clear ID if stopped or idle
            // Final update to button states might be needed if stopped automatically
            if (stopped) {
                 chargeButton.disabled = false;
                 dischargeButton.disabled = (Math.abs(Vc) < 0.01);
            }
        }
    }

    // --- Start ---
    document.addEventListener('DOMContentLoaded', init); // Ensure DOM is ready before running init
</script>
          </body>
        </html>
        