
        <html>
          <head>
            <style>        :root {
          --primary-color: #007bff;
          /* Bootstrap primary blue */
          --secondary-color: #6c757d;
          /* Bootstrap secondary gray */
          --success-color: #28a745;
          /* Bootstrap success green */
          --info-color: #17a2b8;
          /* Bootstrap info cyan */
          --warning-color: #ffc107;
          /* Bootstrap warning yellow */
          --danger-color: #dc3545;
          /* Bootstrap danger red */
          --light-color: #f8f9fa;
          /* Bootstrap light gray */
          --dark-color: #343a40;
          /* Bootstrap dark gray */
          --table-header-bg: var(--dark-color);
          --table-header-color: #ffffff;
          --table-hover-bg: #e9ecef;
          --pivot-row-bg: rgba(220, 53, 69, 0.1);
          /* Lighter danger for row */
          --pivot-col-bg: rgba(23, 162, 184, 0.1);
          /* Lighter info for col */
          --pivot-el-bg: rgba(255, 193, 7, 0.35);
          /* Brighter warning for element */
          --border-color: #ced4da;
          /* Lighter border for a softer look */
          --base-font-size: 1rem;
          --font-family-sans-serif: 'Segoe UI', Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif;
        }

        body {
          font-family: var(--font-family-sans-serif);
          background-color: var(--light-color);
          color: var(--dark-color);
          font-size: var(--base-font-size);
          line-height: 1.7;
          /* Increased for better readability */
          padding-top: 2rem;
          padding-bottom: 2rem;
        }

        h1 {
          color: var(--primary-color);
          font-weight: 700;
          /* Bolder title */
          margin-bottom: 2rem;
          text-align: center;
        }

        .input-section {
          background: #ffffff;
          padding: 2.5rem;
          /* More padding */
          border-radius: 0.75rem;
          box-shadow: 0 6px 20px rgba(0, 0, 0, 0.08);
          /* Softer shadow */
          margin-bottom: 2.5rem;
          max-width: 1200px;
          margin-left: auto;
          margin-right: auto;
          border-top: 5px solid var(--primary-color);
          /* Accent line */
        }

        .input-section h2 {
          font-size: 1.75rem;
          color: var(--dark-color);
          margin-bottom: 1.5rem;
          border-bottom: 1px solid var(--border-color);
          padding-bottom: 0.75rem;
        }

        .tables-container {
          width: 100%;
          overflow-x: auto;
          margin-bottom: 2rem;
          max-width: 1200px;
          margin-left: auto;
          margin-right: auto;
          padding: 1rem;
          background-color: #ffffff;
          border-radius: 0.5rem;
          box-shadow: 0 4px 12px rgba(0, 0, 0, 0.06);
        }

        table {
          border-collapse: collapse;
          width: 100%;
          min-width: 750px;
          /* Slightly increased min-width */
          margin-bottom: 2rem;
          background: white;
          border-radius: 0.375rem;
          overflow: hidden;
          font-size: 0.9rem;
          /* Slightly smaller font in table for density */
        }

        th,
        td {
          padding: 0.75rem 0.9rem;
          /* Adjusted padding */
          text-align: center;
          vertical-align: middle;
          border: 1px solid var(--border-color);
          white-space: nowrap;
        }

        th {
          background-color: var(--table-header-bg);
          color: var(--table-header-color);
          font-weight: 600;
          position: sticky;
          top: 0;
          z-index: 10;
        }

        caption {
          caption-side: top;
          padding: 0.85rem 1rem;
          font-weight: 700;
          /* Bolder caption */
          font-size: 1.25rem;
          /* Larger caption */
          color: var(--primary-color);
          text-align: left;
          /* Align to left for a modern feel */
          background-color: var(--light-color);
          border: 1px solid var(--border-color);
          border-bottom: 3px solid var(--primary-color);
          border-radius: 0.375rem 0.375rem 0 0;
          /* Rounded top corners */
        }

        tbody tr:hover {
          background-color: var(--table-hover-bg);
        }

        .highlight-leaving-row td {
          background-color: var(--pivot-row-bg) !important;
          font-weight: 500;
        }

        .highlight-entering-col {
          background-color: var(--pivot-col-bg) !important;
          font-weight: 500;
        }

        .highlight-pivot-el {
          background-color: var(--pivot-el-bg) !important;
          font-weight: 700;
          outline: 3px solid var(--warning-color);
          outline-offset: -2px;
          color: var(--dark-color);
          /* Ensure text is readable */
        }

        tbody tr:last-child td.highlight-entering-col {
          /* Cj-Zj row cell in entering col */
          background-color: var(--pivot-col-bg) !important;
          font-weight: 700;
        }


        .fraction {
          display: inline-flex;
          /* Use flex for better alignment */
          flex-direction: column;
          text-align: center;
          vertical-align: middle;
          line-height: 1;
          margin: -3px 1px;
        }

        .fraction span {
          display: block;
          padding: 1px 2px;
        }

        .fraction .numerator {
          border-bottom: 1.5px solid currentColor;
        }

        .fraction .denominator {
          padding-top: 1px;
        }

        .explanation-box,
        .solution-box {
          border-left-width: 6px;
          /* Thicker border */
          border-radius: 0.5rem;
          /* Slightly more rounded */
          padding: 1.5rem;
          /* More padding */
          margin-top: 1rem;
          /* Ensure space from table */
          margin-bottom: 2rem;
          max-width: 1200px;
          margin-left: auto;
          margin-right: auto;
          box-shadow: 0 3px 10px rgba(0, 0, 0, 0.05);
        }

        .explanation-box {
          border-left-color: var(--info-color);
          background-color: #e8f7fa;
          /* Lighter info */
          color: #0c5460;
          /* Darker text for info */
        }

        .solution-box {
          border-left-color: var(--success-color);
          background-color: #d4edda;
          /* Lighter success */
          color: #155724;
          /* Darker text for success */
        }

        .explanation-box h5,
        .solution-box h4 {
          margin-top: 0;
          font-weight: 700;
          /* Bolder headers */
          color: inherit;
          /* Inherit color from parent box */
        }

        .solution-box ul {
          padding-left: 1.75rem;
          margin-bottom: 0;
        }

        .solution-box li {
          margin-bottom: 0.4rem;
        }

        .explanation-box strong,
        .solution-box strong {
          font-weight: 600;
        }

        .explanation-box .math-rule {
          font-style: italic;
          color: var(--secondary-color);
          margin-bottom: 0.5rem;
          display: block;
        }


        .button-group {
          display: flex;
          gap: 1rem;
          flex-wrap: wrap;
          margin-top: 2rem;
          /* More space above buttons */
          justify-content: center;
          /* Center buttons */
        }

        .btn {
          padding: 0.75rem 1.5rem;
          /* Larger buttons */
          font-weight: 500;
          border-radius: 0.375rem;
          /* Bootstrap default */
        }

        .btn-primary {
          background-color: var(--primary-color);
          border-color: var(--primary-color);
        }

        .btn-info {
          background-color: var(--info-color);
          border-color: var(--info-color);
          color: white;
        }

        .btn-outline-danger {
          border-color: var(--danger-color);
          color: var(--danger-color);
        }

        .btn-outline-danger:hover {
          background-color: var(--danger-color);
          color: white;
        }


        label.form-label {
          font-weight: 600;
          /* Bolder labels */
          margin-bottom: 0.6rem;
          color: var(--dark-color);
        }

        textarea.form-control,
        input.form-control {
          min-height: 50px;
          font-family: 'Courier New', Courier, monospace;
          /* Monospace for inputs */
          border-radius: 0.375rem;
          border-color: var(--border-color);
        }

        textarea.form-control {
          min-height: 120px;
        }

        .form-text {
          font-size: 0.9em;
          margin-top: 0.5rem;
          /* More space for form text */
          color: var(--secondary-color);
        }

        .alert-info-custom {
          background-color: #e2f3f5;
          border-color: #b8e0e6;
          color: #0c5460;
          padding: 1rem;
          border-radius: 0.375rem;
          margin-bottom: 1rem;
        }</style>
          </head>
          <body>
            <script src="https://cdn.jsdelivr.net/npm/fraction.js@4.3.7/fraction.min.js"></script>
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet"
    integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"
    integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz" crossorigin="anonymous">
</script>

<div class="container py-5">
    <h1>🎓 Dual Simplex Solver</h1>

    <div class="input-section">
        <h2>Problem Setup</h2>
        <form onsubmit="return false;">
            <div class="alert alert-info-custom" role="alert">
                💡 <b>Tip : </b> The Dual Simplex method is typically used when an initial basic solution is infeasible
                (some RHS values are negative) but the optimality condition (C<sub>j</sub>-Z<sub>j</sub> ≤ 0 for
                maximization) is met.
            </div>

            <div class="mb-4">
                <label for="objective" class="form-label">Objective Function Coefficients (Maximize):</label>
                <input type="text" id="objective" class="form-control" placeholder="e.g., -2, -1, 0 (for Min 2x₁ + x₂ with x₃)">
                <div class="form-text">
                    Enter coefficients for a <strong>Maximization</strong> problem, separated by commas.
                    <br>Example: For <code>Max P = 3x₁ + 5x₂</code>, enter <code>3,5</code>.
                    <br>If you have a Minimization problem (e.g., <code>Min Z = 2x₁ + x₂</code>), convert it to
                    Maximization: <code>Max P = -Z = -2x₁ - x₂</code>. Then enter <code>-2,-1</code>.
                </div>
            </div>

            <div class="mb-4">
                <label for="constraints" class="form-label">Constraints (Ax ≤ b):</label>
                <textarea id="constraints" rows="7" class="form-control" placeholder="Enter one constraint per line. Use only '<=' relation.
Example for Max P = -2x₁ - x₂
Subject to:
-x₁ - x₂ ≤ -1
-2x₁ + x₂ ≤ -2
x₁ ≤  3

Enter as:
-1,-1,<=,-1
-2,1,<=,-2
1,0,<=,3"></textarea>
                <div class="form-text">
                    Format: <code>coeff₁,coeff₂,...,coeffₙ,&lt;=,RHS</code>.
                    <br>Each constraint must be of the type '≤'. Slack variables (s₁, s₂, ...) will be added automatically.
                    <br>Initial Right-Hand Side (RHS) values can be negative (this is where Dual Simplex shines!).
                </div>
            </div>

            <div class="button-group">
                <button type="button" onclick="initializeProblem()" class="btn btn-primary shadow-sm">🚀 Initialize Tableau</button>
                <button type="button" id="nextBtn" onclick="performIteration()" style="display: none;" class="btn btn-info shadow-sm">➡️ Next Iteration</button>
                <button type="button" onclick="resetSolver()" class="btn btn-outline-danger shadow-sm">🔄 Reset Solver</button>
            </div>
        </form>
    </div>

    <div id="solverOutput" class="mt-4">
        <div id="tablesContainer" class="tables-container" style="display:none;">
        </div>
        <div id="solutionContainer">
        </div>
    </div>
</div>
            <script>let currentState = null;
const TOLERANCE = 1e-9; // Global tolerance

function frac(value) {
    try {
        let num = Number(value);
        if (Math.abs(num) < TOLERANCE) num = 0; // Normalize near-zero numbers
        return new Fraction(num);
    } catch (e) {
        console.error("Fraction error for value:", value, e);
        return new Fraction(0); // Default to 0 on error
    }
}

function formatFrac(f) {
    if (!(f instanceof Fraction)) {
        try { f = frac(f); } catch { return 'NaN'; }
    }
    if (isNaN(f.n) || isNaN(f.d)) return 'NaN';
    if (f.d === 1) return f.s * f.n;
    if (f.n === 0) return 0;
    return `<div class="fraction"><span class="numerator">${f.s * f.n}</span><span class="denominator">${f.d}</span></div>`;
}

function parseObjective() {
    const input = document.getElementById('objective').value.trim();
    if (!input) {
        alert('Objective function coefficients cannot be empty. Please enter comma-separated numbers.');
        return null;
    }
    const coefficients = input.split(',').map(s => s.trim()).map(Number);
    if (coefficients.some(isNaN)) {
        alert('Invalid objective function coefficients. Ensure they are comma-separated numbers (e.g., 3,5,0).');
        return null;
    }
    return coefficients;
}

function parseConstraints() {
    const input = document.getElementById('constraints').value.trim();
    if (!input) {
        alert('Constraints cannot be empty. Please enter constraints, one per line.');
        return null;
    }
    const lines = input.split('\n').map(line => line.trim()).filter(line => line);
    const constraints = [];
    let numVars = -1;

    for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        const parts = line.split(',').map(p => p.trim());
        if (parts.length < 3) {
            alert(`Error in Constraint ${i + 1}: '${line}'. Expected format: coeff1,coeff2,...,relation,rhs`);
            return null;
        }
        const relation = parts[parts.length - 2].toUpperCase();
        if (relation !== '<=') {
            alert(`Error in Constraint ${i + 1}: '${line}'. Only '<=' relation is supported for automatic slack variable addition in this solver.`);
            return null;
        }
        const rhsStr = parts[parts.length - 1];
        const coefficientsStr = parts.slice(0, -2);
        const rhs = Number(rhsStr);
        if (isNaN(rhs)) {
            alert(`Error in Constraint ${i + 1}: Invalid RHS value '${rhsStr}'. Must be a number.`);
            return null;
        }
        const coefficients = coefficientsStr.map(Number);
        if (coefficients.some(isNaN)) {
            alert(`Error in Constraint ${i + 1}: Invalid coefficients '${coefficientsStr.join(',')}' Some are not numbers.`);
            return null;
        }
        if (numVars === -1) {
            numVars = coefficients.length;
            if (numVars === 0) {
                alert(`Error in Constraint ${i + 1}: No variable coefficients found.`);
                return null;
            }
        } else if (numVars !== coefficients.length) {
            alert(`Error in Constraint ${i + 1}: Inconsistent number of variables. Expected ${numVars} (from first constraint) but got ${coefficients.length}.`);
            return null;
        }
        constraints.push({ coefficients, relation, rhs });
    }
    if (constraints.length === 0) {
        alert("No valid constraints were entered.");
        return null;
    }
    return constraints;
}

function initializeProblem() {
    const objectiveCoeffs = parseObjective();
    const constraints = parseConstraints();

    if (!objectiveCoeffs || !constraints) return;
    if (constraints.length === 0) {
        alert("Please enter at least one constraint.");
        return;
    }
    if (objectiveCoeffs.length !== constraints[0].coefficients.length) {
        alert("The number of objective function coefficients must match the number of variables in each constraint.");
        return;
    }

    currentState = createInitialState(objectiveCoeffs, constraints);
    document.getElementById('tablesContainer').innerHTML = '';
    document.getElementById('solutionContainer').innerHTML = '';
    document.getElementById('tablesContainer').style.display = 'block';

    // Initial check for Dual Simplex applicability
    const { cjZj } = calculateZjCjZj(currentState);
    const isCjZjOptimal = cjZj.every(c => c.compare(TOLERANCE) <= 0); // cjZj <= 0 (approx)
    const hasNegativeRHS = currentState.rows.some(row => row[row.length - 1].compare(-TOLERANCE) < 0); // rhs < 0 (approx)

    if (!isCjZjOptimal) {
        currentState.explanation = "⚠️ **Initial Check Failed for Dual Simplex:** The C<sub>j</sub>-Z<sub>j</sub> row is not optimal (all values ≤ 0). The Dual Simplex method requires the initial tableau to satisfy this condition. You might need to use the standard Simplex method or Big-M method if your problem starts this way and has non-negative RHS.";
        currentState.pivotInfo = null;
        renderState(currentState);
        document.getElementById('nextBtn').style.display = 'none'; // Cannot proceed
        return;
    }

    if (!hasNegativeRHS && isCjZjOptimal) {
        currentState.explanation = "🎉 **Initial Tableau is Already Optimal and Feasible!** All RHS values are non-negative, and all C<sub>j</sub>-Z<sub>j</sub> values are non-positive. No iterations are needed.";
        currentState.isOptimal = true;
        currentState.pivotInfo = null;
        renderState(currentState);
        document.getElementById('nextBtn').style.display = 'none';
        return;
    }

    currentState.explanation = `<strong>Step 0: Initial Tableau Construction</strong>
                <p>The problem has been set up. We've added slack variables (s<sub>1</sub>, s<sub>2</sub>, etc.) to convert inequalities into equalities.
                The initial basic variables are these slack variables.
                The C<sub>j</sub>-Z<sub>j</sub> row is calculated.
                For Dual Simplex to proceed, we need at least one negative RHS value (which we have, or we'd be optimal/infeasible based on Cj-Zj), and all C<sub>j</sub>-Z<sub>j</sub> values must be ≤ 0 (optimality condition for maximization).</p>
                <p class="mt-2"><strong>Next:</strong> If there are negative values in the RHS column, we will select a leaving variable and then an entering variable to perform a pivot operation.</p>`;

    renderState(currentState);
    document.getElementById('nextBtn').style.display = 'inline-block';
    document.getElementById('nextBtn').disabled = false;
}

function resetSolver() {
    currentState = null;
    document.getElementById('tablesContainer').innerHTML = '';
    document.getElementById('solutionContainer').innerHTML = '';
    document.getElementById('tablesContainer').style.display = 'none';
    document.getElementById('nextBtn').style.display = 'none';
    document.getElementById('objective').value = '';
    document.getElementById('constraints').value = '';
    document.getElementById('solverOutput').scrollIntoView({ behavior: 'smooth' });
}

function createInitialState(objectiveCoeffs, constraints) {
    const numVars = objectiveCoeffs.length;
    const numConstraints = constraints.length;
    const variables = [];
    for (let i = 0; i < numVars; i++) variables.push(`x${i + 1}`);
    for (let i = 0; i < numConstraints; i++) variables.push(`s${i + 1}`);

    const rows = [];
    const basis = [];
    const cb = [];

    constraints.forEach((constraint, i) => {
        const rowCoeffs = constraint.coefficients.map(c => frac(c));
        const slackCoeffs = Array(numConstraints).fill(0).map((_, j) => frac(i === j ? 1 : 0));
        const row = [...rowCoeffs, ...slackCoeffs, frac(constraint.rhs)];
        rows.push(row);
        basis.push(`s${i + 1}`);
        cb.push(frac(0));
    });

    const cj = objectiveCoeffs.map(c => frac(c)).concat(Array(numConstraints).fill(frac(0)));

    return {
        variables, cj, basis, cb, rows,
        iteration: 0, explanation: "", isOptimal: false, isInfeasible: false, pivotInfo: null
    };
}

function calculateZjCjZj(state) {
    const numTotalVars = state.variables.length;
    const zj = Array(numTotalVars).fill(frac(0));
    let currentZ = frac(0);

    state.rows.forEach((row, i) => {
        const basicVarCost = (state.cb[i] instanceof Fraction) ? state.cb[i] : frac(state.cb[i]);
        const rhs = row[numTotalVars];
        currentZ = currentZ.add(basicVarCost.mul(rhs));
        for (let j = 0; j < numTotalVars; j++) {
            const cellValue = row[j];
            zj[j] = zj[j].add(basicVarCost.mul(cellValue));
        }
    });
    const cjZj = state.cj.map((c_j_val, j) => {
        const c_j = (c_j_val instanceof Fraction) ? c_j_val : frac(c_j_val);
        return c_j.sub(zj[j]);
    });
    return { zj, cjZj, currentZ };
}

function renderState(state) {
    const container = document.getElementById('tablesContainer');
    const { zj, cjZj, currentZ } = calculateZjCjZj(state);

    const table = document.createElement('table');
    table.className = 'table table-bordered table-hover table-sm align-middle shadow-sm';

    const caption = table.createCaption();
    caption.textContent = `📋 Tableau - Iteration ${state.iteration}`;

    const thead = table.createTHead();
    const headerRow1 = thead.insertRow();
    headerRow1.innerHTML = `<th scope="col">Basis</th><th scope="col">C<sub>B</sub></th>` +
        state.variables.map(v => `<th scope="col">${v}</th>`).join('') +
        `<th scope="col">RHS (b<sub>i</sub>)</th>`;
    const cjRow = thead.insertRow();
    cjRow.innerHTML = `<td class="fw-bold">C<sub>j</sub>&nbsp;➔</td><td></td>` +
        state.cj.map(c => `<td>${formatFrac(c)}</td>`).join('') +
        `<td></td>`;
    const tbody = table.createTBody();

    state.rows.forEach((rowData, i) => {
        const row = tbody.insertRow();
        if (state.pivotInfo && i === state.pivotInfo.leavingIndex) {
            row.classList.add('highlight-leaving-row');
        }
        row.insertCell().outerHTML = `<th scope="row">${state.basis[i]}</th>`;
        row.insertCell().innerHTML = formatFrac(state.cb[i]);
        rowData.slice(0, -1).forEach((val, j) => {
            const cell = row.insertCell();
            cell.innerHTML = formatFrac(val);
            if (state.pivotInfo) {
                if (j === state.pivotInfo.enteringIndex) cell.classList.add('highlight-entering-col');
                if (i === state.pivotInfo.leavingIndex && j === state.pivotInfo.enteringIndex) cell.classList.add('highlight-pivot-el');
            }
        });
        const rhsCell = row.insertCell();
        rhsCell.innerHTML = formatFrac(rowData[rowData.length - 1]);
        if (state.pivotInfo && state.pivotInfo.enteringIndex === state.variables.length) { // Should not happen in Dual Simplex logic
            rhsCell.classList.add('highlight-entering-col');
        }
    });

    const zjRow = tbody.insertRow();
    zjRow.innerHTML = `<td class="fw-bold">Z<sub>j</sub>&nbsp;➔</td><td class="fw-bold" title="Current Objective Value (P)">${formatFrac(currentZ)}</td>` +
        zj.map(z => `<td>${formatFrac(z)}</td>`).join('') + `<td></td>`;
    const cjZjRow = tbody.insertRow();
    cjZjRow.innerHTML = `<td class="fw-bold">C<sub>j</sub>-Z<sub>j</sub>&nbsp;➔</td><td></td>` +
        cjZj.map((c, j) => {
            const cell = document.createElement('td');
            cell.innerHTML = formatFrac(c);
            if (state.pivotInfo && j === state.pivotInfo.enteringIndex) cell.classList.add('highlight-entering-col');
            return cell.outerHTML;
        }).join('') + `<td></td>`;
    container.appendChild(table);

    const explanationDiv = document.createElement('div');
    explanationDiv.className = 'explanation-box';
    let explanationHTML = `<h5 class="mb-3">📝 Iteration ${state.iteration} Analysis</h5> ${state.explanation}`;

    if (state.isOptimal) {
        explanationHTML += `<div class="mt-3 alert alert-success fw-bold">Solution is Optimal and Feasible. See results below.</div>`;
        displaySolution(state, cjZj, currentZ);
        document.getElementById('nextBtn').disabled = true;
    } else if (state.isInfeasible) {
        explanationHTML += `<div class="mt-3 alert alert-danger fw-bold">Problem is Infeasible. No valid solution exists under the given constraints.</div>`;
        document.getElementById('nextBtn').disabled = true;
    }

    explanationDiv.innerHTML = explanationHTML;
    container.appendChild(explanationDiv);
    explanationDiv.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
}

function displaySolution(state, cjZj, currentZ) {
    const solutionContainer = document.getElementById('solutionContainer');
    solutionContainer.innerHTML = '';
    let originalMinZ = null;
    // Check if original problem was likely a min by checking if all objective coeffs were negative
    const originalObjectiveCoeffs = document.getElementById('objective').value.split(',').map(Number);
    if (originalObjectiveCoeffs.every(c => c <= 0) && !originalObjectiveCoeffs.every(c => c === 0)) {
        originalMinZ = currentZ.neg();
    }


    let solutionHTML = `<div class="solution-box"><h4>🏆 Optimal Solution Found!</h4>`;
    solutionHTML += `<p class="lead">Maximum Objective Value (P<sub>max</sub>): <strong>${formatFrac(currentZ)}</strong> (approx. ${currentZ.valueOf().toFixed(4)})</p>`;
    if (originalMinZ !== null) {
        solutionHTML += `<p>This corresponds to an original Minimum Objective Value (Z<sub>min</sub>) of: <strong>${formatFrac(originalMinZ)}</strong> (approx. ${originalMinZ.valueOf().toFixed(4)})</p>`;
    }

    solutionHTML += `<h6 class="mt-4">Variable Values:</h6><ul>`;
    const solution = {};
    state.variables.forEach(v => solution[v] = frac(0));
    state.basis.forEach((basicVar, i) => {
        const value = state.rows[i][state.variables.length];
        solution[basicVar] = (value instanceof Fraction) ? value : frac(value);
    });
    Object.entries(solution).forEach(([variable, value]) => {
        solutionHTML += `<li><strong>${variable}</strong> = ${formatFrac(value)} (approx. ${value.valueOf().toFixed(4)})</li>`;
    });
    solutionHTML += `</ul><p class="mt-3"><small>Note: Non-basic variables are equal to 0.</small></p></div>`;
    solutionContainer.innerHTML = solutionHTML;
    solutionContainer.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
}

function performIteration() {
    if (!currentState || currentState.isOptimal || currentState.isInfeasible) return;

    const numTotalVars = currentState.variables.length;
    const rhsIndex = numTotalVars;
    const { cjZj, currentZ } = calculateZjCjZj(currentState);
    let explanation = "";

    // --- Dual Simplex Iteration Start ---
    currentState.iteration++;
    explanation += `<strong>Starting Iteration ${currentState.iteration}:</strong><br>`;

    // 1. Check Optimality (Cj-Zj <= 0) - Should already be true for Dual Simplex
    const isCjZjOptimal = cjZj.every(c => c.compare(TOLERANCE) <= 0);
    if (!isCjZjOptimal) {
        currentState.explanation = explanation + `<p class="text-danger">🛑 **Error:** C<sub>j</sub>-Z<sub>j</sub> row is not optimal (all values ≤ 0). Dual Simplex cannot proceed. This indicates an issue or that the standard Simplex method is needed.</p>`;
        currentState.pivotInfo = null; // No pivot
        renderState(currentState);
        document.getElementById('nextBtn').disabled = true;
        return;
    }
    explanation += `<span class="math-rule">Condition Check: All C<sub>j</sub>-Z<sub>j</sub> ≤ 0 (Optimality for Max problem) - Met.</span>`;


    // 2. Select Leaving Variable (Pivot Row)
    //    Rule: Choose the row with the most negative RHS (bᵢ).
    let minRhs = frac(0);
    let leavingIndex = -1;
    currentState.rows.forEach((row, i) => {
        const rhs = row[rhsIndex];
        if (rhs.compare(-TOLERANCE) < 0) { // If rhs < -TOLERANCE (i.e., truly negative)
            if (leavingIndex === -1 || rhs.compare(minRhs) < 0) {
                minRhs = rhs;
                leavingIndex = i;
            }
        }
    });

    if (leavingIndex === -1) { // All RHS are non-negative
        // This means the solution is now feasible and (since Cj-Zj is optimal) also optimal.
        currentState.isOptimal = true;
        currentState.explanation = explanation + `<p class="text-success">🎉 **Optimal Feasible Solution Reached!**</p> <span class="math-rule">Condition Check: All RHS (b<sub>i</sub>) ≥ 0 - Met.</span><br>Since all C<sub>j</sub>-Z<sub>j</sub> ≤ 0 and all b<sub>i</sub> ≥ 0, the current solution is optimal.`;
        currentState.pivotInfo = null;
        renderState(currentState); // Render the final optimal state
        document.getElementById('nextBtn').disabled = true;
        return;
    }

    const leavingVar = currentState.basis[leavingIndex];
    const pivotRowValues = currentState.rows[leavingIndex];
    explanation += `<p><strong>1. Select Leaving Variable (Pivot Row):</strong>
                           <span class="math-rule">Rule: Choose the row with the most negative RHS (b<sub>i</sub>).</span>
                           The most negative RHS is <strong>${formatFrac(minRhs)}</strong> in Row ${leavingIndex + 1}.
                           So, <strong>${leavingVar}</strong> is the leaving variable. This row is highlighted.</p>`;


    // 3. Select Entering Variable (Pivot Column)
    //    Rule: For all negative coefficients (a_kj < 0) in the pivot row, calculate the ratio |(Cj-Zj)_j / a_kj|.
    //    Choose the column with the minimum absolute ratio.
    let minRatio = null;
    let enteringIndex = null;
    const ratios = {}; // {columnIndex: {ratio: Fraction, cjZj: Fraction, pivotRowCoeff: Fraction}}

    for (let j = 0; j < numTotalVars; j++) {
        const pivotRowCoeff = pivotRowValues[j];
        if (pivotRowCoeff.compare(-TOLERANCE) < 0) { // If pivotRowCoeff < -TOLERANCE (strictly negative)
            const cjZj_j = cjZj[j];
            // Ratio is (Cj-Zj)_j / pivotRowCoeff_j. We are looking for min of |ratio|.
            // Since Cj-Zj <= 0 and pivotRowCoeff < 0, the ratio itself (Cj-Zj/pivotRowCoeff) will be >= 0.
            // So, min |ratio| is just min(ratio).
            const ratio = cjZj_j.div(pivotRowCoeff); // This will be non-negative
            ratios[j] = { ratio: ratio, cjZj: cjZj_j, pivotRowCoeff: pivotRowCoeff };

            if (enteringIndex === null || ratio.compare(minRatio) < 0) {
                minRatio = ratio;
                enteringIndex = j;
            } else if (ratio.compare(minRatio) === 0) { // Tie-breaking (Bland's rule: smallest index)
                if (j < enteringIndex) {
                    enteringIndex = j;
                }
            }
        }
    }

    // 4. Check for Infeasibility
    if (enteringIndex === null) {
        currentState.isInfeasible = true;
        explanation += `<p class="text-danger"><strong>🛑 Infeasibility Condition Met:</strong>
                               The pivot row (Row ${leavingIndex + 1} for leaving variable ${leavingVar}) has a negative RHS (b<sub>i</sub> < 0),
                               but all coefficients (a<sub>kj</sub>) in this row are non-negative (≥ 0).
                               It's impossible to make the RHS positive through a pivot operation with these conditions.</p>
                               <p>Therefore, the problem is <strong>infeasible</strong>.</p>`;
        currentState.pivotInfo = { leavingIndex: leavingIndex, enteringIndex: null, pivotValue: null, ratios: null };
        currentState.explanation = explanation;
        renderState(currentState);
        document.getElementById('nextBtn').disabled = true;
        return;
    }

    const enteringVar = currentState.variables[enteringIndex];
    const pivotValue = pivotRowValues[enteringIndex];

    explanation += `<p><strong>2. Select Entering Variable (Pivot Column):</strong>
                           <span class="math-rule">Rule: For each <i>negative</i> coefficient (a<sub>kj</sub> < 0) in the pivot row, calculate the ratio: | (C<sub>j</sub>-Z<sub>j</sub>)<sub>j</sub> / a<sub>kj</sub> |. Choose the variable corresponding to the minimum ratio.</span>
                           Ratios calculated:`;
    let ratioStrings = [];
    for (const colIdxStr in ratios) {
        const colIdx = parseInt(colIdxStr);
        const rData = ratios[colIdx];
        ratioStrings.push(`Var ${currentState.variables[colIdx]}: | ${formatFrac(rData.cjZj)} / ${formatFrac(rData.pivotRowCoeff)} | = ${formatFrac(rData.ratio)} (≈${rData.ratio.valueOf().toFixed(3)})`);
    }
    explanation += `<ul><li>${ratioStrings.join('</li><li>')}</li></ul>
                           The minimum ratio is <strong>${formatFrac(minRatio)}</strong> for variable <strong>${enteringVar}</strong> (Column ${enteringIndex + 1}).
                           So, <strong>${enteringVar}</strong> is the entering variable. This column is highlighted.</p>`;
    explanation += `<p><strong>3. Pivot Element:</strong> The pivot element is at the intersection of the leaving row and entering column: <strong>${formatFrac(pivotValue)}</strong>.</p>`;
    explanation += `<p><strong>4. Perform Pivot Operation (Row Operations):</strong>
                           <span class="math-rule">a) New Pivot Row = Old Pivot Row / Pivot Element.<br>
                           b) New Other Row = Old Other Row - (Its Pivot Column Coefficient × New Pivot Row).</span>
                           The tableau will now be updated.</p>`;


    // Store pivot info for rendering highlights *before* modifications
    currentState.pivotInfo = {
        leavingIndex: leavingIndex,
        enteringIndex: enteringIndex,
        pivotValue: pivotValue,
        ratios: ratios // Not strictly needed for rendering but good for potential debugging/extended explanation
    };
    currentState.explanation = explanation; // Set explanation *before* rendering this intermediate step
    renderState(currentState); // Render the state *showing the selection* before performing the pivot calculation

    // --- Perform Pivot Calculation for the *next* state ---

    // Create a new state object for the result of this iteration to avoid modifying during render/explanation
    const nextState = JSON.parse(JSON.stringify(currentState)); // Deep copy (simple version, Fraction objects will be lost)
    // Re-hydrate Fraction objects
    nextState.cj = currentState.cj.map(c => frac(c.toString()));
    nextState.cb = currentState.cb.map(c => frac(c.toString()));
    nextState.rows = currentState.rows.map(row => row.map(val => frac(val.toString())));


    // Update Basis and CB in the next state
    nextState.basis[leavingIndex] = enteringVar;
    nextState.cb[leavingIndex] = nextState.cj[enteringIndex];

    // Normalize Pivot Row in the next state
    const newPivotRow = nextState.rows[leavingIndex];
    if (pivotValue.abs().compare(TOLERANCE) < TOLERANCE) {
        console.error("Pivot value is too close to zero:", pivotValue.valueOf());
        alert("Error: Pivot value is effectively zero. Cannot proceed. This might indicate a data entry error or degeneracy.");
        document.getElementById('nextBtn').disabled = true;
        return;
    }
    for (let j = 0; j <= numTotalVars; j++) { // Include RHS
        newPivotRow[j] = newPivotRow[j].div(pivotValue);
        if (newPivotRow[j].abs().compare(TOLERANCE) < TOLERANCE) newPivotRow[j] = frac(0);
    }

    // Update Other Rows in the next state
    nextState.rows.forEach((row, i) => {
        if (i === leavingIndex) return; // Skip the pivot row itself
        const factor = row[enteringIndex];
        if (factor.abs().compare(TOLERANCE) < TOLERANCE) return; // No change needed

        for (let j = 0; j <= numTotalVars; j++) {
            const pivotRowNormalizedValue = newPivotRow[j];
            row[j] = row[j].sub(factor.mul(pivotRowNormalizedValue));
            if (row[j].abs().compare(TOLERANCE) < TOLERANCE) row[j] = frac(0);
        }
    });

    // Update current state to be the new state
    currentState = nextState;
    currentState.pivotInfo = null; // Clear pivot info for the *next* iteration's selection process
    // Explanation for the *next* state will be generated when `performIteration` is called again or optimality is determined.
    // The explanation currently rendered is for the selection process of *this* iteration.

    // The next render will happen at the start of the next performIteration call, or if it's optimal/infeasible now.
    // Let's check immediately if the new state is optimal to provide instant feedback
    const { cjZj: nextCjZj } = calculateZjCjZj(currentState); // Recalculate for the new state
    const nextHasNegativeRHS = currentState.rows.some(row => row[row.length - 1].compare(-TOLERANCE) < 0);

    if (!nextHasNegativeRHS) { // All RHS are now non-negative
        const nextIsCjZjOptimal = nextCjZj.every(c => c.compare(TOLERANCE) <= 0);
        if (nextIsCjZjOptimal) {
            currentState.isOptimal = true;
            currentState.explanation = explanation + `<p class="mt-3 text-success fw-bold">✅ Pivot operations complete. All RHS values are now non-negative and C<sub>j</sub>-Z<sub>j</sub> remains optimal. Solution is optimal and feasible.</p>`;
            renderState(currentState); // Render the final optimal state
            document.getElementById('nextBtn').disabled = true;
            return;
        }
    }
    document.getElementById('nextBtn').disabled = false; // Re-enable for next step

} // End performIteration
</script>
          </body>
        </html>
        