
        <html>
          <head>
            <style>        :root {
          --primary-color: #007bff;
          /* Bootstrap primary blue */
          --secondary-color: #6c757d;
          /* Bootstrap secondary gray */
          --success-color: #28a745;
          /* Bootstrap success green */
          --info-color: #17a2b8;
          /* Bootstrap info cyan */
          --warning-color: #ffc107;
          /* Bootstrap warning yellow */
          --danger-color: #dc3545;
          /* Bootstrap danger red */
          --light-color: #f8f9fa;
          /* Bootstrap light gray */
          --dark-color: #343a40;
          /* Bootstrap dark gray */
          --table-header-bg: var(--dark-color);
          --table-header-color: #ffffff;
          --table-hover-bg: #e9ecef;
          --pivot-row-bg: rgba(220, 53, 69, 0.1);
          /* Lighter danger for row */
          --pivot-col-bg: rgba(23, 162, 184, 0.1);
          /* Lighter info for col */
          --pivot-el-bg: rgba(255, 193, 7, 0.35);
          /* Brighter warning for element */
          --border-color: #ced4da;
          /* Lighter border for a softer look */
          --base-font-size: 1rem;
          --font-family-sans-serif: 'Segoe UI', Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif;
        }

        body {
          font-family: var(--font-family-sans-serif);
          background-color: var(--light-color);
          color: var(--dark-color);
          font-size: var(--base-font-size);
          line-height: 1.7;
          /* Increased for better readability */
          padding-top: 2rem;
          padding-bottom: 2rem;
        }

        h1 {
          color: var(--primary-color);
          font-weight: 700;
          /* Bolder title */
          margin-bottom: 2rem;
          text-align: center;
        }

        .input-section {
          background: #ffffff;
          padding: 2.5rem;
          /* More padding */
          border-radius: 0.75rem;
          box-shadow: 0 6px 20px rgba(0, 0, 0, 0.08);
          /* Softer shadow */
          margin-bottom: 2.5rem;
          max-width: 1200px;
          margin-left: auto;
          margin-right: auto;
          border-top: 5px solid var(--primary-color);
          /* Accent line */
        }

        .input-section h2 {
          font-size: 1.75rem;
          color: var(--dark-color);
          margin-bottom: 1.5rem;
          border-bottom: 1px solid var(--border-color);
          padding-bottom: 0.75rem;
        }

        .tables-container {
          width: 100%;
          overflow-x: auto;
          margin-bottom: 2rem;
          max-width: 1200px;
          margin-left: auto;
          margin-right: auto;
          padding: 1rem;
          background-color: #ffffff;
          border-radius: 0.5rem;
          box-shadow: 0 4px 12px rgba(0, 0, 0, 0.06);
        }

        table {
          border-collapse: collapse;
          width: 100%;
          min-width: 750px;
          /* Slightly increased min-width */
          margin-bottom: 2rem;
          background: white;
          border-radius: 0.375rem;
          overflow: hidden;
          font-size: 0.9rem;
          /* Slightly smaller font in table for density */
        }

        th,
        td {
          padding: 0.75rem 0.9rem;
          /* Adjusted padding */
          text-align: center;
          vertical-align: middle;
          border: 1px solid var(--border-color);
          white-space: nowrap;
        }

        th {
          background-color: var(--table-header-bg);
          color: var(--table-header-color);
          font-weight: 600;
          position: sticky;
          top: 0;
          z-index: 10;
        }

        caption {
          caption-side: top;
          padding: 0.85rem 1rem;
          font-weight: 700;
          /* Bolder caption */
          font-size: 1.25rem;
          /* Larger caption */
          color: var(--primary-color);
          text-align: left;
          /* Align to left for a modern feel */
          background-color: var(--light-color);
          border: 1px solid var(--border-color);
          border-bottom: 3px solid var(--primary-color);
          border-radius: 0.375rem 0.375rem 0 0;
          /* Rounded top corners */
        }

        tbody tr:hover {
          background-color: var(--table-hover-bg);
        }

        .highlight-leaving-row td {
          background-color: var(--pivot-row-bg) !important;
          font-weight: 500;
        }

        .highlight-entering-col {
          background-color: var(--pivot-col-bg) !important;
          font-weight: 500;
        }

        .highlight-pivot-el {
          background-color: var(--pivot-el-bg) !important;
          font-weight: 700;
          outline: 3px solid var(--warning-color);
          outline-offset: -2px;
          color: var(--dark-color);
          /* Ensure text is readable */
        }

        tbody tr:last-child td.highlight-entering-col {
          /* Cj-Zj row cell in entering col */
          background-color: var(--pivot-col-bg) !important;
          font-weight: 700;
        }


        .fraction {
          display: inline-flex;
          /* Use flex for better alignment */
          flex-direction: column;
          text-align: center;
          vertical-align: middle;
          line-height: 1;
          margin: -3px 1px;
        }

        .fraction span {
          display: block;
          padding: 1px 2px;
        }

        .fraction .numerator {
          border-bottom: 1.5px solid currentColor;
        }

        .fraction .denominator {
          padding-top: 1px;
        }

        .explanation-box,
        .solution-box {
          border-left-width: 6px;
          /* Thicker border */
          border-radius: 0.5rem;
          /* Slightly more rounded */
          padding: 1.5rem;
          /* More padding */
          margin-top: 1rem;
          /* Ensure space from table */
          margin-bottom: 2rem;
          max-width: 1200px;
          margin-left: auto;
          margin-right: auto;
          box-shadow: 0 3px 10px rgba(0, 0, 0, 0.05);
        }

        .explanation-box {
          border-left-color: var(--info-color);
          background-color: #e8f7fa;
          /* Lighter info */
          color: #0c5460;
          /* Darker text for info */
        }

        .solution-box {
          border-left-color: var(--success-color);
          background-color: #d4edda;
          /* Lighter success */
          color: #155724;
          /* Darker text for success */
        }

        .explanation-box h5,
        .solution-box h4 {
          margin-top: 0;
          font-weight: 700;
          /* Bolder headers */
          color: inherit;
          /* Inherit color from parent box */
        }

        .solution-box ul {
          padding-left: 1.75rem;
          margin-bottom: 0;
        }

        .solution-box li {
          margin-bottom: 0.4rem;
        }

        .explanation-box strong,
        .solution-box strong {
          font-weight: 600;
        }

        .explanation-box .math-rule {
          font-style: italic;
          color: var(--secondary-color);
          margin-bottom: 0.5rem;
          display: block;
        }


        .button-group {
          display: flex;
          gap: 1rem;
          flex-wrap: wrap;
          margin-top: 2rem;
          /* More space above buttons */
          justify-content: center;
          /* Center buttons */
        }

        .btn {
          padding: 0.75rem 1.5rem;
          /* Larger buttons */
          font-weight: 500;
          border-radius: 0.375rem;
          /* Bootstrap default */
        }

        .btn-primary {
          background-color: var(--primary-color);
          border-color: var(--primary-color);
        }

        .btn-info {
          background-color: var(--info-color);
          border-color: var(--info-color);
          color: white;
        }

        .btn-outline-danger {
          border-color: var(--danger-color);
          color: var(--danger-color);
        }

        .btn-outline-danger:hover {
          background-color: var(--danger-color);
          color: white;
        }


        label.form-label {
          font-weight: 600;
          /* Bolder labels */
          margin-bottom: 0.6rem;
          color: var(--dark-color);
        }

        textarea.form-control,
        input.form-control {
          min-height: 50px;
          font-family: 'Courier New', Courier, monospace;
          /* Monospace for inputs */
          border-radius: 0.375rem;
          border-color: var(--border-color);
        }

        textarea.form-control {
          min-height: 120px;
        }

        .form-text {
          font-size: 0.9em;
          margin-top: 0.5rem;
          /* More space for form text */
          color: var(--secondary-color);
        }

        .alert-info-custom {
          background-color: #e2f3f5;
          border-color: #b8e0e6;
          color: #0c5460;
          padding: 1rem;
          border-radius: 0.375rem;
          margin-bottom: 1rem;
        }</style>
          </head>
          <body>
            <script src="https://cdn.jsdelivr.net/npm/fraction.js@4.3.7/fraction.min.js"></script>
<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet"
    integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"
    integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz" crossorigin="anonymous">
</script>

<div class="container py-5">
    <h1>üéì Dual Simplex Solver</h1>

    <div class="input-section">
        <h2>Problem Setup</h2>
        <form onsubmit="return false;">
            <div class="alert alert-info-custom" role="alert">
                üí° <b>Tip : </b> The Dual Simplex method is typically used when an initial basic solution is infeasible
                (some RHS values are negative) but the optimality condition (C<sub>j</sub>-Z<sub>j</sub> ‚â§ 0 for
                maximization) is met.
            </div>

            <div class="mb-4">
                <label for="objective" class="form-label">Objective Function Coefficients (Maximize):</label>
                <input type="text" id="objective" class="form-control" placeholder="e.g., -2, -1, 0 (for Min 2x‚ÇÅ + x‚ÇÇ with x‚ÇÉ)">
                <div class="form-text">
                    Enter coefficients for a <strong>Maximization</strong> problem, separated by commas.
                    <br>Example: For <code>Max P = 3x‚ÇÅ + 5x‚ÇÇ</code>, enter <code>3,5</code>.
                    <br>If you have a Minimization problem (e.g., <code>Min Z = 2x‚ÇÅ + x‚ÇÇ</code>), convert it to
                    Maximization: <code>Max P = -Z = -2x‚ÇÅ - x‚ÇÇ</code>. Then enter <code>-2,-1</code>.
                </div>
            </div>

            <div class="mb-4">
                <label for="constraints" class="form-label">Constraints (Ax ‚â§ b):</label>
                <textarea id="constraints" rows="7" class="form-control" placeholder="Enter one constraint per line. Use only '<=' relation.
Example for Max P = -2x‚ÇÅ - x‚ÇÇ
Subject to:
-x‚ÇÅ - x‚ÇÇ ‚â§ -1
-2x‚ÇÅ + x‚ÇÇ ‚â§ -2
x‚ÇÅ ‚â§  3

Enter as:
-1,-1,<=,-1
-2,1,<=,-2
1,0,<=,3"></textarea>
                <div class="form-text">
                    Format: <code>coeff‚ÇÅ,coeff‚ÇÇ,...,coeff‚Çô,&lt;=,RHS</code>.
                    <br>Each constraint must be of the type '‚â§'. Slack variables (s‚ÇÅ, s‚ÇÇ, ...) will be added automatically.
                    <br>Initial Right-Hand Side (RHS) values can be negative (this is where Dual Simplex shines!).
                </div>
            </div>

            <div class="button-group">
                <button type="button" onclick="initializeProblem()" class="btn btn-primary shadow-sm">üöÄ Initialize Tableau</button>
                <button type="button" id="nextBtn" onclick="performIteration()" style="display: none;" class="btn btn-info shadow-sm">‚û°Ô∏è Next Iteration</button>
                <button type="button" onclick="resetSolver()" class="btn btn-outline-danger shadow-sm">üîÑ Reset Solver</button>
            </div>
        </form>
    </div>

    <div id="solverOutput" class="mt-4">
        <div id="tablesContainer" class="tables-container" style="display:none;">
        </div>
        <div id="solutionContainer">
        </div>
    </div>
</div>
            <script>let currentState = null;
const TOLERANCE = 1e-9; // Global tolerance

function frac(value) {
    try {
        let num = Number(value);
        if (Math.abs(num) < TOLERANCE) num = 0; // Normalize near-zero numbers
        return new Fraction(num);
    } catch (e) {
        console.error("Fraction error for value:", value, e);
        return new Fraction(0); // Default to 0 on error
    }
}

function formatFrac(f) {
    if (!(f instanceof Fraction)) {
        try { f = frac(f); } catch { return 'NaN'; }
    }
    if (isNaN(f.n) || isNaN(f.d)) return 'NaN';
    if (f.d === 1) return f.s * f.n;
    if (f.n === 0) return 0;
    return `<div class="fraction"><span class="numerator">${f.s * f.n}</span><span class="denominator">${f.d}</span></div>`;
}

function parseObjective() {
    const input = document.getElementById('objective').value.trim();
    if (!input) {
        alert('Objective function coefficients cannot be empty. Please enter comma-separated numbers.');
        return null;
    }
    const coefficients = input.split(',').map(s => s.trim()).map(Number);
    if (coefficients.some(isNaN)) {
        alert('Invalid objective function coefficients. Ensure they are comma-separated numbers (e.g., 3,5,0).');
        return null;
    }
    return coefficients;
}

function parseConstraints() {
    const input = document.getElementById('constraints').value.trim();
    if (!input) {
        alert('Constraints cannot be empty. Please enter constraints, one per line.');
        return null;
    }
    const lines = input.split('\n').map(line => line.trim()).filter(line => line);
    const constraints = [];
    let numVars = -1;

    for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        const parts = line.split(',').map(p => p.trim());
        if (parts.length < 3) {
            alert(`Error in Constraint ${i + 1}: '${line}'. Expected format: coeff1,coeff2,...,relation,rhs`);
            return null;
        }
        const relation = parts[parts.length - 2].toUpperCase();
        if (relation !== '<=') {
            alert(`Error in Constraint ${i + 1}: '${line}'. Only '<=' relation is supported for automatic slack variable addition in this solver.`);
            return null;
        }
        const rhsStr = parts[parts.length - 1];
        const coefficientsStr = parts.slice(0, -2);
        const rhs = Number(rhsStr);
        if (isNaN(rhs)) {
            alert(`Error in Constraint ${i + 1}: Invalid RHS value '${rhsStr}'. Must be a number.`);
            return null;
        }
        const coefficients = coefficientsStr.map(Number);
        if (coefficients.some(isNaN)) {
            alert(`Error in Constraint ${i + 1}: Invalid coefficients '${coefficientsStr.join(',')}' Some are not numbers.`);
            return null;
        }
        if (numVars === -1) {
            numVars = coefficients.length;
            if (numVars === 0) {
                alert(`Error in Constraint ${i + 1}: No variable coefficients found.`);
                return null;
            }
        } else if (numVars !== coefficients.length) {
            alert(`Error in Constraint ${i + 1}: Inconsistent number of variables. Expected ${numVars} (from first constraint) but got ${coefficients.length}.`);
            return null;
        }
        constraints.push({ coefficients, relation, rhs });
    }
    if (constraints.length === 0) {
        alert("No valid constraints were entered.");
        return null;
    }
    return constraints;
}

function initializeProblem() {
    const objectiveCoeffs = parseObjective();
    const constraints = parseConstraints();

    if (!objectiveCoeffs || !constraints) return;
    if (constraints.length === 0) {
        alert("Please enter at least one constraint.");
        return;
    }
    if (objectiveCoeffs.length !== constraints[0].coefficients.length) {
        alert("The number of objective function coefficients must match the number of variables in each constraint.");
        return;
    }

    currentState = createInitialState(objectiveCoeffs, constraints);
    document.getElementById('tablesContainer').innerHTML = '';
    document.getElementById('solutionContainer').innerHTML = '';
    document.getElementById('tablesContainer').style.display = 'block';

    // Initial check for Dual Simplex applicability
    const { cjZj } = calculateZjCjZj(currentState);
    const isCjZjOptimal = cjZj.every(c => c.compare(TOLERANCE) <= 0); // cjZj <= 0 (approx)
    const hasNegativeRHS = currentState.rows.some(row => row[row.length - 1].compare(-TOLERANCE) < 0); // rhs < 0 (approx)

    if (!isCjZjOptimal) {
        currentState.explanation = "‚ö†Ô∏è **Initial Check Failed for Dual Simplex:** The C<sub>j</sub>-Z<sub>j</sub> row is not optimal (all values ‚â§ 0). The Dual Simplex method requires the initial tableau to satisfy this condition. You might need to use the standard Simplex method or Big-M method if your problem starts this way and has non-negative RHS.";
        currentState.pivotInfo = null;
        renderState(currentState);
        document.getElementById('nextBtn').style.display = 'none'; // Cannot proceed
        return;
    }

    if (!hasNegativeRHS && isCjZjOptimal) {
        currentState.explanation = "üéâ **Initial Tableau is Already Optimal and Feasible!** All RHS values are non-negative, and all C<sub>j</sub>-Z<sub>j</sub> values are non-positive. No iterations are needed.";
        currentState.isOptimal = true;
        currentState.pivotInfo = null;
        renderState(currentState);
        document.getElementById('nextBtn').style.display = 'none';
        return;
    }

    currentState.explanation = `<strong>Step 0: Initial Tableau Construction</strong>
                <p>The problem has been set up. We've added slack variables (s<sub>1</sub>, s<sub>2</sub>, etc.) to convert inequalities into equalities.
                The initial basic variables are these slack variables.
                The C<sub>j</sub>-Z<sub>j</sub> row is calculated.
                For Dual Simplex to proceed, we need at least one negative RHS value (which we have, or we'd be optimal/infeasible based on Cj-Zj), and all C<sub>j</sub>-Z<sub>j</sub> values must be ‚â§ 0 (optimality condition for maximization).</p>
                <p class="mt-2"><strong>Next:</strong> If there are negative values in the RHS column, we will select a leaving variable and then an entering variable to perform a pivot operation.</p>`;

    renderState(currentState);
    document.getElementById('nextBtn').style.display = 'inline-block';
    document.getElementById('nextBtn').disabled = false;
}

function resetSolver() {
    currentState = null;
    document.getElementById('tablesContainer').innerHTML = '';
    document.getElementById('solutionContainer').innerHTML = '';
    document.getElementById('tablesContainer').style.display = 'none';
    document.getElementById('nextBtn').style.display = 'none';
    document.getElementById('objective').value = '';
    document.getElementById('constraints').value = '';
    document.getElementById('solverOutput').scrollIntoView({ behavior: 'smooth' });
}

function createInitialState(objectiveCoeffs, constraints) {
    const numVars = objectiveCoeffs.length;
    const numConstraints = constraints.length;
    const variables = [];
    for (let i = 0; i < numVars; i++) variables.push(`x${i + 1}`);
    for (let i = 0; i < numConstraints; i++) variables.push(`s${i + 1}`);

    const rows = [];
    const basis = [];
    const cb = [];

    constraints.forEach((constraint, i) => {
        const rowCoeffs = constraint.coefficients.map(c => frac(c));
        const slackCoeffs = Array(numConstraints).fill(0).map((_, j) => frac(i === j ? 1 : 0));
        const row = [...rowCoeffs, ...slackCoeffs, frac(constraint.rhs)];
        rows.push(row);
        basis.push(`s${i + 1}`);
        cb.push(frac(0));
    });

    const cj = objectiveCoeffs.map(c => frac(c)).concat(Array(numConstraints).fill(frac(0)));

    return {
        variables, cj, basis, cb, rows,
        iteration: 0, explanation: "", isOptimal: false, isInfeasible: false, pivotInfo: null
    };
}

function calculateZjCjZj(state) {
    const numTotalVars = state.variables.length;
    const zj = Array(numTotalVars).fill(frac(0));
    let currentZ = frac(0);

    state.rows.forEach((row, i) => {
        const basicVarCost = (state.cb[i] instanceof Fraction) ? state.cb[i] : frac(state.cb[i]);
        const rhs = row[numTotalVars];
        currentZ = currentZ.add(basicVarCost.mul(rhs));
        for (let j = 0; j < numTotalVars; j++) {
            const cellValue = row[j];
            zj[j] = zj[j].add(basicVarCost.mul(cellValue));
        }
    });
    const cjZj = state.cj.map((c_j_val, j) => {
        const c_j = (c_j_val instanceof Fraction) ? c_j_val : frac(c_j_val);
        return c_j.sub(zj[j]);
    });
    return { zj, cjZj, currentZ };
}

function renderState(state) {
    const container = document.getElementById('tablesContainer');
    const { zj, cjZj, currentZ } = calculateZjCjZj(state);

    const table = document.createElement('table');
    table.className = 'table table-bordered table-hover table-sm align-middle shadow-sm';

    const caption = table.createCaption();
    caption.textContent = `üìã Tableau - Iteration ${state.iteration}`;

    const thead = table.createTHead();
    const headerRow1 = thead.insertRow();
    headerRow1.innerHTML = `<th scope="col">Basis</th><th scope="col">C<sub>B</sub></th>` +
        state.variables.map(v => `<th scope="col">${v}</th>`).join('') +
        `<th scope="col">RHS (b<sub>i</sub>)</th>`;
    const cjRow = thead.insertRow();
    cjRow.innerHTML = `<td class="fw-bold">C<sub>j</sub>&nbsp;‚ûî</td><td></td>` +
        state.cj.map(c => `<td>${formatFrac(c)}</td>`).join('') +
        `<td></td>`;
    const tbody = table.createTBody();

    state.rows.forEach((rowData, i) => {
        const row = tbody.insertRow();
        if (state.pivotInfo && i === state.pivotInfo.leavingIndex) {
            row.classList.add('highlight-leaving-row');
        }
        row.insertCell().outerHTML = `<th scope="row">${state.basis[i]}</th>`;
        row.insertCell().innerHTML = formatFrac(state.cb[i]);
        rowData.slice(0, -1).forEach((val, j) => {
            const cell = row.insertCell();
            cell.innerHTML = formatFrac(val);
            if (state.pivotInfo) {
                if (j === state.pivotInfo.enteringIndex) cell.classList.add('highlight-entering-col');
                if (i === state.pivotInfo.leavingIndex && j === state.pivotInfo.enteringIndex) cell.classList.add('highlight-pivot-el');
            }
        });
        const rhsCell = row.insertCell();
        rhsCell.innerHTML = formatFrac(rowData[rowData.length - 1]);
        if (state.pivotInfo && state.pivotInfo.enteringIndex === state.variables.length) { // Should not happen in Dual Simplex logic
            rhsCell.classList.add('highlight-entering-col');
        }
    });

    const zjRow = tbody.insertRow();
    zjRow.innerHTML = `<td class="fw-bold">Z<sub>j</sub>&nbsp;‚ûî</td><td class="fw-bold" title="Current Objective Value (P)">${formatFrac(currentZ)}</td>` +
        zj.map(z => `<td>${formatFrac(z)}</td>`).join('') + `<td></td>`;
    const cjZjRow = tbody.insertRow();
    cjZjRow.innerHTML = `<td class="fw-bold">C<sub>j</sub>-Z<sub>j</sub>&nbsp;‚ûî</td><td></td>` +
        cjZj.map((c, j) => {
            const cell = document.createElement('td');
            cell.innerHTML = formatFrac(c);
            if (state.pivotInfo && j === state.pivotInfo.enteringIndex) cell.classList.add('highlight-entering-col');
            return cell.outerHTML;
        }).join('') + `<td></td>`;
    container.appendChild(table);

    const explanationDiv = document.createElement('div');
    explanationDiv.className = 'explanation-box';
    let explanationHTML = `<h5 class="mb-3">üìù Iteration ${state.iteration} Analysis</h5> ${state.explanation}`;

    if (state.isOptimal) {
        explanationHTML += `<div class="mt-3 alert alert-success fw-bold">Solution is Optimal and Feasible. See results below.</div>`;
        displaySolution(state, cjZj, currentZ);
        document.getElementById('nextBtn').disabled = true;
    } else if (state.isInfeasible) {
        explanationHTML += `<div class="mt-3 alert alert-danger fw-bold">Problem is Infeasible. No valid solution exists under the given constraints.</div>`;
        document.getElementById('nextBtn').disabled = true;
    }

    explanationDiv.innerHTML = explanationHTML;
    container.appendChild(explanationDiv);
    explanationDiv.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
}

function displaySolution(state, cjZj, currentZ) {
    const solutionContainer = document.getElementById('solutionContainer');
    solutionContainer.innerHTML = '';
    let originalMinZ = null;
    // Check if original problem was likely a min by checking if all objective coeffs were negative
    const originalObjectiveCoeffs = document.getElementById('objective').value.split(',').map(Number);
    if (originalObjectiveCoeffs.every(c => c <= 0) && !originalObjectiveCoeffs.every(c => c === 0)) {
        originalMinZ = currentZ.neg();
    }


    let solutionHTML = `<div class="solution-box"><h4>üèÜ Optimal Solution Found!</h4>`;
    solutionHTML += `<p class="lead">Maximum Objective Value (P<sub>max</sub>): <strong>${formatFrac(currentZ)}</strong> (approx. ${currentZ.valueOf().toFixed(4)})</p>`;
    if (originalMinZ !== null) {
        solutionHTML += `<p>This corresponds to an original Minimum Objective Value (Z<sub>min</sub>) of: <strong>${formatFrac(originalMinZ)}</strong> (approx. ${originalMinZ.valueOf().toFixed(4)})</p>`;
    }

    solutionHTML += `<h6 class="mt-4">Variable Values:</h6><ul>`;
    const solution = {};
    state.variables.forEach(v => solution[v] = frac(0));
    state.basis.forEach((basicVar, i) => {
        const value = state.rows[i][state.variables.length];
        solution[basicVar] = (value instanceof Fraction) ? value : frac(value);
    });
    Object.entries(solution).forEach(([variable, value]) => {
        solutionHTML += `<li><strong>${variable}</strong> = ${formatFrac(value)} (approx. ${value.valueOf().toFixed(4)})</li>`;
    });
    solutionHTML += `</ul><p class="mt-3"><small>Note: Non-basic variables are equal to 0.</small></p></div>`;
    solutionContainer.innerHTML = solutionHTML;
    solutionContainer.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
}

function performIteration() {
    if (!currentState || currentState.isOptimal || currentState.isInfeasible) return;

    const numTotalVars = currentState.variables.length;
    const rhsIndex = numTotalVars;
    const { cjZj, currentZ } = calculateZjCjZj(currentState);
    let explanation = "";

    // --- Dual Simplex Iteration Start ---
    currentState.iteration++;
    explanation += `<strong>Starting Iteration ${currentState.iteration}:</strong><br>`;

    // 1. Check Optimality (Cj-Zj <= 0) - Should already be true for Dual Simplex
    const isCjZjOptimal = cjZj.every(c => c.compare(TOLERANCE) <= 0);
    if (!isCjZjOptimal) {
        currentState.explanation = explanation + `<p class="text-danger">üõë **Error:** C<sub>j</sub>-Z<sub>j</sub> row is not optimal (all values ‚â§ 0). Dual Simplex cannot proceed. This indicates an issue or that the standard Simplex method is needed.</p>`;
        currentState.pivotInfo = null; // No pivot
        renderState(currentState);
        document.getElementById('nextBtn').disabled = true;
        return;
    }
    explanation += `<span class="math-rule">Condition Check: All C<sub>j</sub>-Z<sub>j</sub> ‚â§ 0 (Optimality for Max problem) - Met.</span>`;


    // 2. Select Leaving Variable (Pivot Row)
    //    Rule: Choose the row with the most negative RHS (b·µ¢).
    let minRhs = frac(0);
    let leavingIndex = -1;
    currentState.rows.forEach((row, i) => {
        const rhs = row[rhsIndex];
        if (rhs.compare(-TOLERANCE) < 0) { // If rhs < -TOLERANCE (i.e., truly negative)
            if (leavingIndex === -1 || rhs.compare(minRhs) < 0) {
                minRhs = rhs;
                leavingIndex = i;
            }
        }
    });

    if (leavingIndex === -1) { // All RHS are non-negative
        // This means the solution is now feasible and (since Cj-Zj is optimal) also optimal.
        currentState.isOptimal = true;
        currentState.explanation = explanation + `<p class="text-success">üéâ **Optimal Feasible Solution Reached!**</p> <span class="math-rule">Condition Check: All RHS (b<sub>i</sub>) ‚â• 0 - Met.</span><br>Since all C<sub>j</sub>-Z<sub>j</sub> ‚â§ 0 and all b<sub>i</sub> ‚â• 0, the current solution is optimal.`;
        currentState.pivotInfo = null;
        renderState(currentState); // Render the final optimal state
        document.getElementById('nextBtn').disabled = true;
        return;
    }

    const leavingVar = currentState.basis[leavingIndex];
    const pivotRowValues = currentState.rows[leavingIndex];
    explanation += `<p><strong>1. Select Leaving Variable (Pivot Row):</strong>
                           <span class="math-rule">Rule: Choose the row with the most negative RHS (b<sub>i</sub>).</span>
                           The most negative RHS is <strong>${formatFrac(minRhs)}</strong> in Row ${leavingIndex + 1}.
                           So, <strong>${leavingVar}</strong> is the leaving variable. This row is highlighted.</p>`;


    // 3. Select Entering Variable (Pivot Column)
    //    Rule: For all negative coefficients (a_kj < 0) in the pivot row, calculate the ratio |(Cj-Zj)_j / a_kj|.
    //    Choose the column with the minimum absolute ratio.
    let minRatio = null;
    let enteringIndex = null;
    const ratios = {}; // {columnIndex: {ratio: Fraction, cjZj: Fraction, pivotRowCoeff: Fraction}}

    for (let j = 0; j < numTotalVars; j++) {
        const pivotRowCoeff = pivotRowValues[j];
        if (pivotRowCoeff.compare(-TOLERANCE) < 0) { // If pivotRowCoeff < -TOLERANCE (strictly negative)
            const cjZj_j = cjZj[j];
            // Ratio is (Cj-Zj)_j / pivotRowCoeff_j. We are looking for min of |ratio|.
            // Since Cj-Zj <= 0 and pivotRowCoeff < 0, the ratio itself (Cj-Zj/pivotRowCoeff) will be >= 0.
            // So, min |ratio| is just min(ratio).
            const ratio = cjZj_j.div(pivotRowCoeff); // This will be non-negative
            ratios[j] = { ratio: ratio, cjZj: cjZj_j, pivotRowCoeff: pivotRowCoeff };

            if (enteringIndex === null || ratio.compare(minRatio) < 0) {
                minRatio = ratio;
                enteringIndex = j;
            } else if (ratio.compare(minRatio) === 0) { // Tie-breaking (Bland's rule: smallest index)
                if (j < enteringIndex) {
                    enteringIndex = j;
                }
            }
        }
    }

    // 4. Check for Infeasibility
    if (enteringIndex === null) {
        currentState.isInfeasible = true;
        explanation += `<p class="text-danger"><strong>üõë Infeasibility Condition Met:</strong>
                               The pivot row (Row ${leavingIndex + 1} for leaving variable ${leavingVar}) has a negative RHS (b<sub>i</sub> < 0),
                               but all coefficients (a<sub>kj</sub>) in this row are non-negative (‚â• 0).
                               It's impossible to make the RHS positive through a pivot operation with these conditions.</p>
                               <p>Therefore, the problem is <strong>infeasible</strong>.</p>`;
        currentState.pivotInfo = { leavingIndex: leavingIndex, enteringIndex: null, pivotValue: null, ratios: null };
        currentState.explanation = explanation;
        renderState(currentState);
        document.getElementById('nextBtn').disabled = true;
        return;
    }

    const enteringVar = currentState.variables[enteringIndex];
    const pivotValue = pivotRowValues[enteringIndex];

    explanation += `<p><strong>2. Select Entering Variable (Pivot Column):</strong>
                           <span class="math-rule">Rule: For each <i>negative</i> coefficient (a<sub>kj</sub> < 0) in the pivot row, calculate the ratio: | (C<sub>j</sub>-Z<sub>j</sub>)<sub>j</sub> / a<sub>kj</sub> |. Choose the variable corresponding to the minimum ratio.</span>
                           Ratios calculated:`;
    let ratioStrings = [];
    for (const colIdxStr in ratios) {
        const colIdx = parseInt(colIdxStr);
        const rData = ratios[colIdx];
        ratioStrings.push(`Var ${currentState.variables[colIdx]}: | ${formatFrac(rData.cjZj)} / ${formatFrac(rData.pivotRowCoeff)} | = ${formatFrac(rData.ratio)} (‚âà${rData.ratio.valueOf().toFixed(3)})`);
    }
    explanation += `<ul><li>${ratioStrings.join('</li><li>')}</li></ul>
                           The minimum ratio is <strong>${formatFrac(minRatio)}</strong> for variable <strong>${enteringVar}</strong> (Column ${enteringIndex + 1}).
                           So, <strong>${enteringVar}</strong> is the entering variable. This column is highlighted.</p>`;
    explanation += `<p><strong>3. Pivot Element:</strong> The pivot element is at the intersection of the leaving row and entering column: <strong>${formatFrac(pivotValue)}</strong>.</p>`;
    explanation += `<p><strong>4. Perform Pivot Operation (Row Operations):</strong>
                           <span class="math-rule">a) New Pivot Row = Old Pivot Row / Pivot Element.<br>
                           b) New Other Row = Old Other Row - (Its Pivot Column Coefficient √ó New Pivot Row).</span>
                           The tableau will now be updated.</p>`;


    // Store pivot info for rendering highlights *before* modifications
    currentState.pivotInfo = {
        leavingIndex: leavingIndex,
        enteringIndex: enteringIndex,
        pivotValue: pivotValue,
        ratios: ratios // Not strictly needed for rendering but good for potential debugging/extended explanation
    };
    currentState.explanation = explanation; // Set explanation *before* rendering this intermediate step
    renderState(currentState); // Render the state *showing the selection* before performing the pivot calculation

    // --- Perform Pivot Calculation for the *next* state ---

    // Create a new state object for the result of this iteration to avoid modifying during render/explanation
    const nextState = JSON.parse(JSON.stringify(currentState)); // Deep copy (simple version, Fraction objects will be lost)
    // Re-hydrate Fraction objects
    nextState.cj = currentState.cj.map(c => frac(c.toString()));
    nextState.cb = currentState.cb.map(c => frac(c.toString()));
    nextState.rows = currentState.rows.map(row => row.map(val => frac(val.toString())));


    // Update Basis and CB in the next state
    nextState.basis[leavingIndex] = enteringVar;
    nextState.cb[leavingIndex] = nextState.cj[enteringIndex];

    // Normalize Pivot Row in the next state
    const newPivotRow = nextState.rows[leavingIndex];
    if (pivotValue.abs().compare(TOLERANCE) < TOLERANCE) {
        console.error("Pivot value is too close to zero:", pivotValue.valueOf());
        alert("Error: Pivot value is effectively zero. Cannot proceed. This might indicate a data entry error or degeneracy.");
        document.getElementById('nextBtn').disabled = true;
        return;
    }
    for (let j = 0; j <= numTotalVars; j++) { // Include RHS
        newPivotRow[j] = newPivotRow[j].div(pivotValue);
        if (newPivotRow[j].abs().compare(TOLERANCE) < TOLERANCE) newPivotRow[j] = frac(0);
    }

    // Update Other Rows in the next state
    nextState.rows.forEach((row, i) => {
        if (i === leavingIndex) return; // Skip the pivot row itself
        const factor = row[enteringIndex];
        if (factor.abs().compare(TOLERANCE) < TOLERANCE) return; // No change needed

        for (let j = 0; j <= numTotalVars; j++) {
            const pivotRowNormalizedValue = newPivotRow[j];
            row[j] = row[j].sub(factor.mul(pivotRowNormalizedValue));
            if (row[j].abs().compare(TOLERANCE) < TOLERANCE) row[j] = frac(0);
        }
    });

    // Update current state to be the new state
    currentState = nextState;
    currentState.pivotInfo = null; // Clear pivot info for the *next* iteration's selection process
    // Explanation for the *next* state will be generated when `performIteration` is called again or optimality is determined.
    // The explanation currently rendered is for the selection process of *this* iteration.

    // The next render will happen at the start of the next performIteration call, or if it's optimal/infeasible now.
    // Let's check immediately if the new state is optimal to provide instant feedback
    const { cjZj: nextCjZj } = calculateZjCjZj(currentState); // Recalculate for the new state
    const nextHasNegativeRHS = currentState.rows.some(row => row[row.length - 1].compare(-TOLERANCE) < 0);

    if (!nextHasNegativeRHS) { // All RHS are now non-negative
        const nextIsCjZjOptimal = nextCjZj.every(c => c.compare(TOLERANCE) <= 0);
        if (nextIsCjZjOptimal) {
            currentState.isOptimal = true;
            currentState.explanation = explanation + `<p class="mt-3 text-success fw-bold">‚úÖ Pivot operations complete. All RHS values are now non-negative and C<sub>j</sub>-Z<sub>j</sub> remains optimal. Solution is optimal and feasible.</p>`;
            renderState(currentState); // Render the final optimal state
            document.getElementById('nextBtn').disabled = true;
            return;
        }
    }
    document.getElementById('nextBtn').disabled = false; // Re-enable for next step

} // End performIteration
</script>
          </body>
        </html>
        